# Code Aggregation Output
# Generated on: Sat Nov 29 22:23:20 IST 2025
# Scanned folders: core

================================================================================================
FILE: core/go.mod
================================================================================================

module github.com/kuchuk-borom-debbarma/GitGrove/core

go 1.25.4

require github.com/rs/zerolog v1.34.0

require (
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.19 // indirect
	golang.org/x/sys v0.12.0 // indirect
)


================================================================================================
FILE: core/internal/util/file/file.go
================================================================================================

package file

import (
	"encoding/json"
	"errors"
	"os"
	"path/filepath"
	"strings"
)

// NormalizePath cleans a path and converts "\" → "/".
//
// It uses filepath.Clean to resolve dot-dots and remove extraneous separators,
// then forces forward slashes to ensure consistency across platforms (Windows/Linux/macOS).
// This is crucial for GitGroove metadata which should be platform-agnostic.
func NormalizePath(path string) string {
	if path == "" {
		return ""
	}
	clean := filepath.Clean(path)
	return strings.ReplaceAll(clean, "\\", "/")
}

// Exists checks if a file or directory exists at the given path.
//
// It returns true if the path exists (regardless of type), and false otherwise.
// Note: It returns false for any error (e.g., permission denied), not just "not found".
func Exists(path string) bool {
	path = NormalizePath(path)
	_, err := os.Stat(path)
	return err == nil
}

// EnsureNotExists verifies that the given path does not exist.
//
// It returns an error if the path exists, or nil if it does not.
// Used for idempotency checks (e.g., ensuring we don't overwrite an existing .gg).
func EnsureNotExists(path string) error {
	path = NormalizePath(path)
	if Exists(path) {
		return errors.New("path already exists: " + path)
	}
	return nil
}

// CreateDir creates a directory and all necessary parents (mkdir -p).
//
// It uses permission 0755 (rwxr-xr-x).
// Returns an error if creation fails.
func CreateDir(path string) error {
	path = NormalizePath(path)
	if err := os.MkdirAll(path, 0755); err != nil {
		return errors.New("failed to create directory " + path + ": " + err.Error())
	}
	return nil
}

// CreateEmptyFile creates an empty file at the specified path.
//
// It automatically creates any missing parent directories.
// Returns an error if directory creation or file creation fails.
func CreateEmptyFile(path string) error {
	path = NormalizePath(path)
	if err := CreateDir(filepath.Dir(path)); err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return errors.New("failed to create file " + path + ": " + err.Error())
	}
	return f.Close()
}

// WriteTextFile writes a string content to a file.
//
// It automatically creates any missing parent directories.
// The file is written with permission 0644 (rw-r--r--).
// If the file exists, it is overwritten.
func WriteTextFile(path string, content string) error {
	path = NormalizePath(path)
	if err := CreateDir(filepath.Dir(path)); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0644)
}

// WriteJSONFile serializes a Go value to a JSON file with indentation.
//
// It automatically creates any missing parent directories.
// The JSON is marshaled with 2-space indentation for readability.
// The file is written with permission 0644.
func WriteJSONFile(path string, v any) error {
	path = NormalizePath(path)
	if err := CreateDir(filepath.Dir(path)); err != nil {
		return err
	}

	data, err := json.MarshalIndent(v, "", "  ")
	if err != nil {
		return errors.New("failed to serialize JSON: " + err.Error())
	}

	return os.WriteFile(path, data, 0644)
}

func ReadTextFile(path string) (string, error) {
	path = NormalizePath(path)
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(data), nil
}

func AppendTextFile(path, content string) error {
	path = NormalizePath(path)
	if err := CreateDir(filepath.Dir(path)); err != nil {
		return err
	}

	f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := f.WriteString(content); err != nil {
		return err
	}
	return nil
}


================================================================================================
FILE: core/internal/util/git/git.go
================================================================================================

package git

import (
	"bytes"
	"errors"
	"os/exec"
	"strings"
)

// Internal helper to run git
func runGit(dir string, args ...string) (string, error) {
	cmd := exec.Command("git", args...)
	cmd.Dir = dir

	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	err := cmd.Run()
	return strings.TrimSpace(out.String()), err
}

// IsInsideGitRepo checks if the given path is inside a Git working tree.
//
// It runs `git rev-parse --is-inside-work-tree`.
// Returns true only if the command succeeds and outputs "true".
func IsInsideGitRepo(path string) bool {
	out, err := runGit(path, "rev-parse", "--is-inside-work-tree")
	return err == nil && out == "true"
}

// IsDetachedHEAD checks if HEAD is detached (not pointing to a branch ref).
//
// It runs `git rev-parse --symbolic-full-name HEAD`.
// If HEAD is detached, the output is "HEAD". If attached, it returns the full ref (e.g., "refs/heads/main").
func IsDetachedHEAD(path string) bool {
	out, err := runGit(path, "rev-parse", "--symbolic-full-name", "HEAD")
	if err != nil {
		return false
	}
	return out == "HEAD"
}

func HasStagedChanges(path string) bool {
	_, err := runGit(path, "diff", "--cached", "--quiet")
	return err != nil
}

func HasUnstagedChanges(path string) bool {
	_, err := runGit(path, "diff", "--quiet")
	return err != nil
}

func HasUntrackedFiles(path string) bool {
	out, err := runGit(path, "ls-files", "--others", "--exclude-standard")
	if err != nil {
		return false
	}
	return strings.TrimSpace(out) != ""
}

// VerifyCleanState ensures the repository is in a clean state suitable for critical operations.
//
// It performs a comprehensive check:
//  1. Is HEAD detached? (We generally require being on a branch for safety, though some ops might work detached).
//  2. Are there staged changes? (git diff --cached --quiet)
//  3. Are there unstaged changes? (git diff --quiet)
//  4. Are there untracked files? (git ls-files --others --exclude-standard)
//
// Returns nil if clean, or an error detailing all found issues.
func VerifyCleanState(path string) error {
	var issues []string

	if IsDetachedHEAD(path) {
		issues = append(issues, "HEAD is detached")
	}
	if HasStagedChanges(path) {
		issues = append(issues, "staged changes exist")
	}
	if HasUnstagedChanges(path) {
		issues = append(issues, "unstaged changes exist")
	}
	if HasUntrackedFiles(path) {
		issues = append(issues, "untracked files exist")
	}

	if len(issues) == 0 {
		return nil
	}

	return errors.New("repository is not clean: " + strings.Join(issues, "; "))
}

// HasBranch checks if a local branch exists.
//
// It uses `git rev-parse --verify --quiet <branch>`.
// Returns true if the branch ref exists, false otherwise.
func HasBranch(path, branch string) (bool, error) {
	_, err := runGit(path, "rev-parse", "--verify", "--quiet", branch)

	if err == nil {
		return true, nil
	}

	if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
		return false, nil
	}

	return false, err
}

func CreateAndCheckoutBranch(path, branch string) error {
	_, err := runGit(path, "checkout", "-b", branch)
	return err
}

func StagePath(repoPath, relativePath string) error {
	_, err := runGit(repoPath, "add", "-f", relativePath)
	return err
}

func Commit(repoPath, message string) error {
	_, err := runGit(repoPath, "commit", "-m", message)
	return err
}

func ResolveRef(repoPath, ref string) (string, error) {
	return runGit(repoPath, "rev-parse", ref)
}

func ShowFile(repoPath, ref, filePath string) (string, error) {
	return runGit(repoPath, "show", ref+":"+filePath)
}

// WorktreeAddDetached creates a temporary linked worktree detached at a specific commit.
//
// This is used for safe metadata manipulation without disturbing the user's primary working tree.
// It runs `git worktree add --detach <worktreePath> <ref>`.
func WorktreeAddDetached(repoPath, worktreePath, ref string) error {
	_, err := runGit(repoPath, "worktree", "add", "--detach", worktreePath, ref)
	return err
}

func WorktreeRemove(repoPath, worktreePath string) error {
	_, err := runGit(repoPath, "worktree", "remove", "--force", worktreePath)
	return err
}

// UpdateRef updates a ref to a new value, but ONLY if it currently matches oldHash.
//
// This implements Optimistic Concurrency Control (CAS - Compare And Swap).
// It runs `git update-ref <ref> <newHash> <oldHash>`.
// If the ref has changed since oldHash was read, this command fails, preventing race conditions.
func UpdateRef(repoPath, ref, newHash, oldHash string) error {
	_, err := runGit(repoPath, "update-ref", ref, newHash, oldHash)
	return err
}

// SetRef updates a ref to a new value unconditionally.
//
// It runs `git update-ref <ref> <newHash>`.
func SetRef(repoPath, ref, newHash string) error {
	_, err := runGit(repoPath, "update-ref", ref, newHash)
	return err
}

func GetHeadCommit(repoPath string) (string, error) {
	return runGit(repoPath, "rev-parse", "HEAD")
}

func ListTree(repoPath, ref, path string) ([]string, error) {
	out, err := runGit(repoPath, "ls-tree", "--name-only", ref+":"+path)
	if err != nil {
		return nil, err
	}
	if out == "" {
		return []string{}, nil
	}
	return strings.Split(out, "\n"), nil
}

func GetCurrentBranch(repoPath string) (string, error) {
	return runGit(repoPath, "rev-parse", "--abbrev-ref", "HEAD")
}

func Checkout(repoPath, branch string) error {
	_, err := runGit(repoPath, "checkout", branch)
	return err
}

func CheckoutPath(repoPath, ref, path string) error {
	_, err := runGit(repoPath, "checkout", ref, "--", path)
	return err
}

func UnstagePath(repoPath, path string) error {
	_, err := runGit(repoPath, "restore", "--staged", path)
	return err
}

func ResetHard(repoPath, ref string) error {
	_, err := runGit(repoPath, "reset", "--hard", ref)
	return err
}

// RefExists checks if a reference exists.
func RefExists(repoPath, ref string) bool {
	_, err := runGit(repoPath, "rev-parse", "--verify", "--quiet", ref)
	return err == nil
}

// Init initializes a new git repository.
func Init(repoPath string) error {
	_, err := runGit(repoPath, "init")
	return err
}

// CreateBranch creates a new branch pointing to the specified start point.
func CreateBranch(repoPath, branch, startPoint string) error {
	_, err := runGit(repoPath, "branch", branch, startPoint)
	return err
}

// RunGit runs an arbitrary git command.
func RunGit(repoPath string, args ...string) (string, error) {
	return runGit(repoPath, args...)
}

// CommitTree creates a commit from a tree object.
func CommitTree(repoPath, treeHash, message string, parents ...string) (string, error) {
	args := []string{"commit-tree", treeHash, "-m", message}
	for _, p := range parents {
		args = append(args, "-p", p)
	}
	return runGit(repoPath, args...)
}

// GetEmptyTreeHash returns the hash of an empty tree.
func GetEmptyTreeHash(repoPath string) (string, error) {
	// The empty tree hash is a constant in git: 4b825dc642cb6eb9a060e54bf8d69288fbee4904
	return "4b825dc642cb6eb9a060e54bf8d69288fbee4904", nil
}


================================================================================================
FILE: core/internal/grove/register.go
================================================================================================

package grove

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove/model"
	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

// Register records one or more repos (name → path) in the GitGroove metadata.
//
// It operates atomically against the latest committed state of the gitgroove/system branch.
// Validated entries are appended to .gg/repos/<name>/path, a new commit is created,
// and the gitgroove/system reference is updated.
//
// Guarantees:
//   - Atomic: either all repos are registered or none.
//   - Safe: validates environment (clean state, valid git repo) and inputs (unique names/paths).
//   - Non-destructive: does not modify user branches or working directory content (except .gitgroverepo marker).
func Register(rootAbsPath string, repos map[string]string) error {
	log.Info().Msgf("Attempting to register %d repos in %s", len(repos), rootAbsPath)

	// 1. Validate environment
	if err := validateRegisterEnvironment(rootAbsPath); err != nil {
		return err
	}

	// 2. Read latest gitgroove/system commit
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		return fmt.Errorf("failed to resolve %s (is GitGroove initialized?): %w", systemRef, err)
	}

	// 3. Load existing repo metadata
	existingRepos, err := loadExistingRepos(rootAbsPath, oldTip)
	if err != nil {
		return fmt.Errorf("failed to load existing repos: %w", err)
	}

	// 4. Validate incoming repos
	if err := validateNewRepos(rootAbsPath, repos, existingRepos); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	// 5. Prepare updated metadata in temporary workspace and create commit
	newTip, err := createRegisterCommit(rootAbsPath, oldTip, repos)
	if err != nil {
		return err
	}

	// 7. Atomically update gitgroove/system
	if err := gitUtil.UpdateRef(rootAbsPath, systemRef, newTip, oldTip); err != nil {
		return fmt.Errorf("failed to update %s (concurrent modification?): %w", systemRef, err)
	}

	// If we are currently on the system branch, we must update the working tree to match the new commit.
	// Otherwise, the working tree will appear "dirty" (missing the new files we just committed).
	currentBranch, err := gitUtil.GetCurrentBranch(rootAbsPath)
	if err == nil && currentBranch == "gitgroove/system" {
		log.Info().Msg("Updating working tree to match new system state")
		if err := gitUtil.ResetHard(rootAbsPath, "HEAD"); err != nil {
			return fmt.Errorf("failed to update working tree: %w", err)
		}
	}

	// 8. Create .gitgroverepo marker in the registered directories
	// This is critical for the stage command to detect nested repos.
	for name, path := range repos {
		// path is relative to rootAbsPath
		absPath := filepath.Join(rootAbsPath, path)
		markerPath := filepath.Join(absPath, ".gitgroverepo")

		// Always overwrite or create the marker with the repo name
		// This ensures identity is correct even if re-registering or if file was empty
		if err := fileUtil.WriteTextFile(markerPath, name); err != nil {
			log.Warn().Msgf("Failed to write marker file at %s: %v", markerPath, err)
			// We don't fail the registration because the metadata is already committed.
		}

		// 9. Create orphan branch for the repo if it doesn't exist
		// Branch: refs/heads/gitgroove/repos/<name>/branches/main
		branchRef := RepoBranchRef(name, model.DefaultRepoBranch)
		if !gitUtil.RefExists(rootAbsPath, branchRef) {
			log.Info().Msgf("Creating orphan branch %s", branchRef)
			// Create an empty orphan branch.
			// We can do this by creating a commit with no parents and an empty tree?
			// Or just using `git checkout --orphan` in a temp worktree?
			// Easiest is `git commit-tree` with empty tree and no parent.
			emptyTreeHash, err := gitUtil.GetEmptyTreeHash(rootAbsPath)
			if err != nil {
				log.Warn().Msgf("Failed to get empty tree hash: %v", err)
				continue
			}

			commitHash, err := gitUtil.CommitTree(rootAbsPath, emptyTreeHash, "Initial empty repo commit")
			if err != nil {
				log.Warn().Msgf("Failed to create orphan branch %s: %v", branchRef, err)
			} else {
				if err := gitUtil.SetRef(rootAbsPath, branchRef, commitHash); err != nil {
					log.Warn().Msgf("Failed to set ref %s: %v", branchRef, err)
				}
			}
		}
	}

	log.Info().Msg("Successfully registered repositories")
	log.Info().Msg("Wrote repo marker files; please commit them if you need them visible on your working branches")
	return nil
}

func validateRegisterEnvironment(rootAbsPath string) error {
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return fmt.Errorf("not a git repository: %s", rootAbsPath)
	}
	if err := gitUtil.VerifyCleanState(rootAbsPath); err != nil {
		return fmt.Errorf("working tree is not clean: %w", err)
	}
	return nil
}

func createRegisterCommit(rootAbsPath, oldTip string, repos map[string]string) (string, error) {
	// 5. Prepare updated metadata in temporary workspace
	tempDir, err := os.MkdirTemp("", "gitgroove-register-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tempDir) // cleanup

	// Create detached worktree at oldTip
	if err := gitUtil.WorktreeAddDetached(rootAbsPath, tempDir, oldTip); err != nil {
		return "", fmt.Errorf("failed to create temporary worktree: %w", err)
	}
	defer gitUtil.WorktreeRemove(rootAbsPath, tempDir) // cleanup worktree

	// Write new repos to .gg/repos/<name>/path AND write marker files
	for name, path := range repos {
		repoDir := filepath.Join(tempDir, ".gg", "repos", name)
		if err := os.MkdirAll(repoDir, 0755); err != nil {
			return "", fmt.Errorf("failed to create dir for repo %s: %w", name, err)
		}

		pathFile := filepath.Join(repoDir, "path")
		// Canonicalize path before writing
		cleanPath := fileUtil.NormalizePath(path)
		if filepath.IsAbs(cleanPath) {
			// Should have been caught by validation, but ensure we write relative
			rel, _ := filepath.Rel(rootAbsPath, cleanPath)
			cleanPath = fileUtil.NormalizePath(rel)
		}

		if err := os.WriteFile(pathFile, []byte(cleanPath), 0644); err != nil {
			return "", fmt.Errorf("failed to write path for repo %s: %w", name, err)
		}

		// Write marker file in the temp worktree so it's included in the system commit
		// We need to create the repo directory structure in the temp worktree
		markerRelPath := filepath.Join(cleanPath, ".gitgroverepo")
		markerAbsPath := filepath.Join(tempDir, markerRelPath)
		if err := os.MkdirAll(filepath.Dir(markerAbsPath), 0755); err != nil {
			return "", fmt.Errorf("failed to create repo dir in temp worktree for %s: %w", name, err)
		}
		if err := os.WriteFile(markerAbsPath, []byte(name), 0644); err != nil {
			return "", fmt.Errorf("failed to write marker in temp worktree for %s: %w", name, err)
		}
	}

	// 6. Create new commit
	// Stage everything in .gg/repos
	if err := gitUtil.StagePath(tempDir, ".gg/repos"); err != nil {
		return "", fmt.Errorf("failed to stage .gg/repos: %w", err)
	}
	// Also stage the marker files (we can just stage the whole tempDir since it's a fresh worktree)
	// But to be safe/precise, let's stage the repo paths.
	// Actually, staging "." in tempDir is safe because it only contains what we wrote + checked out files.
	// But we only want to commit the new markers and .gg changes.
	// Since we are in a detached worktree of gitgroove/system, it only has .gg/ by default.
	// We added repo dirs.
	// Staging "." is fine.
	if err := gitUtil.StagePath(tempDir, "."); err != nil {
		return "", fmt.Errorf("failed to stage changes: %w", err)
	}

	if err := gitUtil.Commit(tempDir, fmt.Sprintf("Register %d new repositories", len(repos))); err != nil {
		return "", fmt.Errorf("failed to commit metadata changes: %w", err)
	}
	newTip, err := gitUtil.GetHeadCommit(tempDir)
	if err != nil {
		return "", fmt.Errorf("failed to get new commit hash: %w", err)
	}
	return newTip, nil
}

func loadExistingRepos(root, ref string) (map[string]model.Repo, error) {
	// List directories in .gg/repos
	// Note: .gg/repos might not exist if no repos are registered yet.
	// git ls-tree will fail if the path doesn't exist.
	// We should check if .gg/repos exists first or handle the error.
	// runGit returns error if path not found.

	entries, err := gitUtil.ListTree(root, ref, ".gg/repos")
	if err != nil {
		// If the directory doesn't exist, it's not an error, just empty.
		// git ls-tree returns error if path not found.
		// We need to distinguish "path not found" from other errors if possible.
		// For now, assuming any error from ListTree on a specific path means it doesn't exist or is empty
		// is a simplification. A better check would be explicitly checking existence.
		// But based on gitUtil implementation, let's assume it returns error if not found.
		return map[string]model.Repo{}, nil
	}

	repos := make(map[string]model.Repo)
	for _, name := range entries {
		// Ignore .gitkeep
		if name == ".gitkeep" {
			continue
		}

		// Each entry is a repo name (directory)
		// Read .gg/repos/<name>/path
		pathFile := fmt.Sprintf(".gg/repos/%s/path", name)
		content, err := gitUtil.ShowFile(root, ref, pathFile)
		if err != nil {
			// If path file is missing, it's a corruption or partial state.
			return nil, fmt.Errorf("failed to read path for repo %s: %w", name, err)
		}

		repoPath := strings.TrimSpace(content)

		// Read .gg/repos/<name>/parent
		parentFile := fmt.Sprintf(".gg/repos/%s/parent", name)
		parentContent, err := gitUtil.ShowFile(root, ref, parentFile)
		parent := ""
		if err == nil {
			parent = strings.TrimSpace(parentContent)
		} else {
			// Parent file might not exist for root repos or newly registered ones
			// We treat error as empty parent
		}

		repos[name] = model.Repo{
			Name:   name,
			Path:   repoPath,
			Parent: parent,
		}
	}

	return repos, nil
}

var validNameRegex = regexp.MustCompile(`^[a-zA-Z0-9._-]+$`)

func validateNewRepos(root string, newRepos map[string]string, existing map[string]model.Repo) error {
	// 1. Check for name collisions and validity
	for name := range newRepos {
		if err := validateRepoName(name, existing); err != nil {
			return err
		}
	}

	// 2. Check for path collisions and validity
	existingPaths := make(map[string]bool)
	for _, r := range existing {
		existingPaths[r.Path] = true
	}

	// Track paths in the current batch to detect duplicates within the batch
	seenPaths := make(map[string]string)

	for name, relPath := range newRepos {
		if err := validateRepoPath(root, name, relPath, existingPaths, seenPaths); err != nil {
			return err
		}
	}

	return nil
}

func validateRepoName(name string, existing map[string]model.Repo) error {
	if !validNameRegex.MatchString(name) {
		return fmt.Errorf("invalid repo name '%s': must match %s", name, validNameRegex.String())
	}
	if _, ok := existing[name]; ok {
		return fmt.Errorf("repo name '%s' already registered", name)
	}
	return nil
}

func validateRepoPath(root, name, relPath string, existingPaths map[string]bool, seenPaths map[string]string) error {
	// Path uniqueness
	cleanPath := fileUtil.NormalizePath(relPath)

	if existingPaths[cleanPath] {
		return fmt.Errorf("path '%s' already registered", relPath)
	}

	if otherName, ok := seenPaths[cleanPath]; ok {
		return fmt.Errorf("duplicate path '%s' used by '%s' and '%s'", relPath, otherName, name)
	}
	seenPaths[cleanPath] = name

	// Existence and containment
	absPath := filepath.Join(root, cleanPath)

	// Verify path is inside root
	rel, err := filepath.Rel(root, absPath)
	if err != nil || strings.HasPrefix(rel, "..") || strings.HasPrefix(rel, "/") {
		return fmt.Errorf("path '%s' escapes project root", relPath)
	}

	info, err := os.Stat(absPath)
	if err != nil {
		return fmt.Errorf("path '%s' does not exist", relPath)
	}
	if !info.IsDir() {
		return fmt.Errorf("path '%s' is not a directory", relPath)
	}

	// No nested .git
	// Exception: if absPath is the root itself, .git is expected.
	if absPath != root && fileUtil.Exists(filepath.Join(absPath, ".git")) {
		return fmt.Errorf("repo '%s' contains .git directory (nested git repos not allowed)", relPath)
	}

	return nil
}


================================================================================================
FILE: core/internal/grove/switch_test.go
================================================================================================

package grove_test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

func TestSwitch(t *testing.T) {
	// Setup temporary directory for the test
	tmpDir, err := os.MkdirTemp("", "gitgroove-switch-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Initialize a git repo
	if err := gitUtil.Init(tmpDir); err != nil {
		t.Fatalf("failed to init git repo: %v", err)
	}

	// Create .gg directory to simulate GitGroove repo
	if err := os.Mkdir(filepath.Join(tmpDir, ".gg"), 0755); err != nil {
		t.Fatalf("failed to create .gg dir: %v", err)
	}

	// Create initial commit
	if err := os.WriteFile(filepath.Join(tmpDir, "README.md"), []byte("# Test Repo"), 0644); err != nil {
		t.Fatalf("failed to write README: %v", err)
	}
	if err := gitUtil.StagePath(tmpDir, "."); err != nil {
		t.Fatalf("failed to stage files: %v", err)
	}
	if err := gitUtil.Commit(tmpDir, "Initial commit"); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Ensure we are on 'main'
	if _, err := gitUtil.RunGit(tmpDir, "branch", "-m", "main"); err != nil {
		t.Fatalf("failed to rename branch to main: %v", err)
	}

	// Create gitgroove/system branch
	if err := gitUtil.CreateBranch(tmpDir, "gitgroove/system", "HEAD"); err != nil {
		t.Fatalf("failed to create system branch: %v", err)
	}

	// Register repos
	repos := map[string]string{
		"root":     ".",
		"backend":  "backend",
		"frontend": "frontend",
	}
	// Create directories for repos
	if err := os.Mkdir(filepath.Join(tmpDir, "backend"), 0755); err != nil {
		t.Fatalf("failed to create backend dir: %v", err)
	}
	if err := os.Mkdir(filepath.Join(tmpDir, "frontend"), 0755); err != nil {
		t.Fatalf("failed to create frontend dir: %v", err)
	}

	// Switch to gitgroove/system to register
	if err := gitUtil.Checkout(tmpDir, "gitgroove/system"); err != nil {
		t.Fatalf("failed to checkout system branch: %v", err)
	}

	if err := grove.Register(tmpDir, repos); err != nil {
		t.Fatalf("Register failed: %v", err)
	}

	// Register creates .gitgroverepo files.
	// Since we are on gitgroove/system, Register commits them to the system branch.
	// So the working tree should be clean and markers tracked.
	// No need to manual commit.

	// Link repos
	relationships := map[string]string{
		"backend":  "root",
		"frontend": "root",
	}
	if err := grove.Link(tmpDir, relationships); err != nil {
		t.Fatalf("Link failed: %v", err)
	}

	// Switch back to main to simulate user working
	if err := gitUtil.Checkout(tmpDir, "main"); err != nil {
		t.Fatalf("failed to checkout main: %v", err)
	}

	// Test Switch
	t.Run("Switch to backend main", func(t *testing.T) {
		if err := grove.Switch(tmpDir, "backend", ""); err != nil {
			t.Fatalf("Switch failed: %v", err)
		}

		// Verify HEAD
		head, err := gitUtil.GetCurrentBranch(tmpDir)
		if err != nil {
			t.Fatalf("failed to get current branch: %v", err)
		}
		expected := "gitgroove/repos/backend/branches/main"
		if head != expected {
			t.Errorf("expected HEAD to be %s, got %s", expected, head)
		}
	})

	t.Run("Switch to frontend main", func(t *testing.T) {
		// Switch requires clean state.
		// We are currently on backend branch. It should be clean.

		if err := grove.Switch(tmpDir, "frontend", "main"); err != nil {
			t.Fatalf("Switch failed: %v", err)
		}

		head, err := gitUtil.GetCurrentBranch(tmpDir)
		if err != nil {
			t.Fatalf("failed to get current branch: %v", err)
		}
		expected := "gitgroove/repos/frontend/branches/main"
		if head != expected {
			t.Errorf("expected HEAD to be %s, got %s", expected, head)
		}
	})

	t.Run("Switch to non-existent repo", func(t *testing.T) {
		if err := grove.Switch(tmpDir, "non-existent", ""); err == nil {
			t.Error("expected error for non-existent repo, got nil")
		}
	})
}


================================================================================================
FILE: core/internal/grove/branch_ref.go
================================================================================================

package grove

import (
	"fmt"
	"strings"
)

const branchPrefix = "refs/heads/gitgroove/repos/"

// RepoBranchRef constructs the full ref for a repo branch.
// Format: refs/heads/gitgroove/repos/<repoName>/branches/<branchName>
func RepoBranchRef(repoName, branchName string) string {
	return fmt.Sprintf("%s%s/branches/%s", branchPrefix, repoName, branchName)
}

// RepoBranchShortFromRef returns the short branch name (without refs/heads/) from a full ref.
func RepoBranchShortFromRef(ref string) string {
	return strings.TrimPrefix(ref, "refs/heads/")
}

// ParseRepoFromBranch extracts the repo name from a GitGrove branch name (short or full).
func ParseRepoFromBranch(branchName string) (string, error) {
	// Accept short or full ref. Normalize.
	short := strings.TrimPrefix(branchName, "refs/heads/")
	if !strings.HasPrefix(short, "gitgroove/repos/") {
		return "", fmt.Errorf("not a valid GitGrove repo branch: %s", branchName)
	}
	// short form: gitgroove/repos/<repoName>/branches/<branch>
	// Split by "/"
	// [gitgroove, repos, <repoName>, branches, <branchName>...]
	parts := strings.Split(short, "/")
	if len(parts) < 5 || parts[3] != "branches" {
		return "", fmt.Errorf("invalid GitGrove branch format: %s", branchName)
	}
	return parts[2], nil
}


================================================================================================
FILE: core/internal/grove/branch_test.go
================================================================================================

package grove_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

func TestCreateRepoBranch(t *testing.T) {
	// Setup
	temp := t.TempDir()
	createDummyProject(t, temp)
	execGit(t, temp, "init")
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "initial commit")

	// Capture default branch
	defaultBranch := strings.TrimSpace(execGit(t, temp, "branch", "--show-current"))

	if err := grove.Init(temp); err != nil {
		t.Fatalf("Init failed: %v", err)
	}

	// Switch back to default branch
	execGit(t, temp, "checkout", defaultBranch)

	// Create directories for repos
	os.MkdirAll(filepath.Join(temp, "services", "grandparent"), 0755)
	os.MkdirAll(filepath.Join(temp, "services", "parent"), 0755)
	os.MkdirAll(filepath.Join(temp, "services", "child"), 0755)

	// Register repos
	repos := map[string]string{
		"grandparent": "services/grandparent",
		"parent":      "services/parent",
		"child":       "services/child",
	}
	if err := grove.Register(temp, repos); err != nil {
		t.Fatalf("Register failed: %v", err)
	}

	// Register creates .gitgroverepo files which are untracked.
	// We need to commit them to have a clean state for Link.
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "Add .gitgroverepo markers")

	// Link repos: grandparent -> parent -> child
	links := map[string]string{
		"parent": "grandparent",
		"child":  "parent",
	}
	if err := grove.Link(temp, links); err != nil {
		t.Fatalf("Link failed: %v", err)
	}

	// Test Case: Create branch for nested child
	branchName := "feature/login"
	if err := grove.CreateRepoBranch(temp, "child", branchName); err != nil {
		t.Fatalf("CreateRepoBranch failed: %v", err)
	}

	// Verify the branch ref exists
	// Expected path: gitgroove/repos/child/branches/feature/login
	expectedRef := "refs/heads/gitgroove/repos/child/branches/feature/login"

	exists, err := gitUtil.HasBranch(temp, expectedRef)
	if err != nil {
		t.Fatalf("HasBranch failed: %v", err)
	}
	if !exists {
		t.Errorf("Expected branch ref %s to exist, but it does not", expectedRef)
	}

	// Verify it points to HEAD
	headCommit, _ := gitUtil.GetHeadCommit(temp)
	branchCommit, _ := gitUtil.ResolveRef(temp, expectedRef)
	if branchCommit != headCommit {
		t.Errorf("Expected branch to point to %s, got %s", headCommit, branchCommit)
	}
}


================================================================================================
FILE: core/internal/grove/link_test.go
================================================================================================

package grove_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

func TestLink(t *testing.T) {
	// Setup
	temp := t.TempDir()
	createDummyProject(t, temp)
	execGit(t, temp, "init")
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "initial commit")

	// Capture default branch
	defaultBranch := strings.TrimSpace(execGit(t, temp, "branch", "--show-current"))

	if err := grove.Init(temp); err != nil {
		t.Fatalf("Init failed: %v", err)
	}

	// Switch back to default branch because Init leaves us on gitgroove/system
	// and Register/Link expect to run from a user branch.
	// If we stay on gitgroove/system, Register's update-ref will make the index appear dirty.
	execGit(t, temp, "checkout", defaultBranch)

	// Create directories for repos
	os.MkdirAll(filepath.Join(temp, "services", "backend"), 0755)
	os.MkdirAll(filepath.Join(temp, "services", "frontend"), 0755)
	os.MkdirAll(filepath.Join(temp, "libs", "shared"), 0755)

	// Register repos
	repos := map[string]string{
		"backend":  "services/backend",
		"frontend": "services/frontend",
		"shared":   "libs/shared",
	}
	if err := grove.Register(temp, repos); err != nil {
		t.Fatalf("Register failed: %v", err)
	}

	// Register creates .gitgroverepo files which are untracked.
	// We need to commit them to have a clean state for Link.
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "Add .gitgroverepo markers")

	// Test Case 1: Successful Linking
	// Hierarchy:
	// shared -> backend
	// shared -> frontend
	links := map[string]string{
		"backend":  "shared",
		"frontend": "shared",
	}
	if err := grove.Link(temp, links); err != nil {
		t.Fatalf("Link failed: %v", err)
	}

	// Verify .gg/repos content
	// Check backend parent
	backendParent, err := gitUtil.ShowFile(temp, "gitgroove/system", ".gg/repos/backend/parent")
	if err != nil {
		t.Fatalf("failed to read backend parent: %v", err)
	}
	if strings.TrimSpace(backendParent) != "shared" {
		t.Errorf("expected backend parent 'shared', got '%s'", backendParent)
	}

	// Check shared children
	// .gg/repos/shared/children/backend should exist
	_, err = gitUtil.ShowFile(temp, "gitgroove/system", ".gg/repos/shared/children/backend")
	if err != nil {
		t.Errorf("expected child entry for backend in shared, got error: %v", err)
	}

	// Verify repo branches exist (created by Register)
	// backend: refs/heads/gitgroove/repos/backend/branches/main
	backendBranch := "refs/heads/gitgroove/repos/backend/branches/main"
	if exists, _ := gitUtil.HasBranch(temp, backendBranch); !exists {
		t.Errorf("expected branch %s to exist", backendBranch)
	}

	// frontend: refs/heads/gitgroove/repos/frontend/branches/main
	frontendBranch := "refs/heads/gitgroove/repos/frontend/branches/main"
	if exists, _ := gitUtil.HasBranch(temp, frontendBranch); !exists {
		t.Errorf("expected branch %s to exist", frontendBranch)
	}

	// shared: refs/heads/gitgroove/repos/shared/branches/main
	sharedBranch := "refs/heads/gitgroove/repos/shared/branches/main"
	if exists, _ := gitUtil.HasBranch(temp, sharedBranch); !exists {
		t.Errorf("expected branch %s to exist", sharedBranch)
	}

	// Test Case 2: Cycle Detection
	// Try to make backend -> shared (creating a cycle shared -> backend -> shared)
	cycleLinks := map[string]string{
		"shared": "backend",
	}
	if err := grove.Link(temp, cycleLinks); err == nil {
		t.Fatal("expected error for cycle, got nil")
	}

	// Test Case 3: Non-existent Parent
	invalidParentLinks := map[string]string{
		"backend": "ghost",
	}
	if err := grove.Link(temp, invalidParentLinks); err == nil {
		t.Fatal("expected error for non-existent parent, got nil")
	}

	// Test Case 4: Non-existent Child
	invalidChildLinks := map[string]string{
		"ghost": "shared",
	}
	if err := grove.Link(temp, invalidChildLinks); err == nil {
		t.Fatal("expected error for non-existent child, got nil")
	}

	// Test Case 5: Self-reference
	selfLinks := map[string]string{
		"backend": "backend",
	}
	if err := grove.Link(temp, selfLinks); err == nil {
		t.Fatal("expected error for self-reference, got nil")
	}

	// Test Case 6: Existing Parent
	// backend already has parent 'shared' from Test Case 1
	// Try to assign it another parent
	reparentLinks := map[string]string{
		"backend": "frontend",
	}
	if err := grove.Link(temp, reparentLinks); err == nil {
		t.Fatal("expected error for existing parent, got nil")
	}

	// Test Case 7: Dangling Repo
	// Delete backend directory
	os.RemoveAll(filepath.Join(temp, "services", "backend"))
	// Try to link something to backend or use backend
	// Note: Link checks child existence.
	// Let's try to link backend to something else (if we could reparent)
	// Or better, register a new repo, delete its dir, then try to link it.

	// But we can't register if dir doesn't exist.
	// So we register, then delete, then link.
	os.MkdirAll(filepath.Join(temp, "dangling"), 0755)
	grove.Register(temp, map[string]string{"dangling": "dangling"})
	os.RemoveAll(filepath.Join(temp, "dangling"))

	danglingLinks := map[string]string{
		"dangling": "shared",
	}
	if err := grove.Link(temp, danglingLinks); err == nil {
		t.Fatal("expected error for dangling repo, got nil")
	}
}


================================================================================================
FILE: core/internal/grove/link.go
================================================================================================

package grove

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove/model"
	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

/*
Link defines hierarchy relationships (childName → parentName) and updates GitGroove metadata.
It operates atomically against the latest committed state of gitgroove/system.

High-Level Responsibility:
  - Connects registered repos into a parent→child tree.
  - Stores relationships in .gg/repos/<repo>/parent and .gg/repos/<parent>/children/<child>.
  - Rebuilds derived repo branches (gitgroove/repos/<repo>/branches/main) based on ancestry.

Guarantees:
  - Atomic: all relationships are applied or none.
  - Safe: validates environment, existence of repos, and absence of cycles.
  - Non-destructive: does not modify user branches or working directory content.
*/
func Link(rootAbsPath string, relationships map[string]string) error {
	rootAbsPath = fileUtil.NormalizePath(rootAbsPath)
	// relationships: child -> parent
	log.Info().Msgf("Attempting to link %d relationships in %s", len(relationships), rootAbsPath)

	// 1. Validate environment
	if err := validateLinkEnvironment(rootAbsPath); err != nil {
		return err
	}

	// 2. Read latest gitgroove/system commit
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		return fmt.Errorf("failed to resolve %s (is GitGroove initialized?): %w", systemRef, err)
	}

	// 3. Load existing repo metadata
	existingRepos, err := loadExistingRepos(rootAbsPath, oldTip)
	if err != nil {
		return fmt.Errorf("failed to load existing repos: %w", err)
	}

	// 4. Validate relationships
	if err := validateRelationships(rootAbsPath, relationships, existingRepos); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	// 5. Prepare updated metadata in temporary workspace and create commit
	newTip, err := applyRelationships(rootAbsPath, oldTip, relationships)
	if err != nil {
		return err
	}

	// 7. Atomically update gitgroove/system
	if err := gitUtil.UpdateRef(rootAbsPath, systemRef, newTip, oldTip); err != nil {
		return fmt.Errorf("failed to update %s (concurrent modification?): %w", systemRef, err)
	}

	// If we are currently on the system branch, we must update the working tree to match the new commit.
	currentBranch, err := gitUtil.GetCurrentBranch(rootAbsPath)
	if err == nil && currentBranch == "gitgroove/system" {
		log.Info().Msg("Updating working tree to match new system state")
		if err := gitUtil.ResetHard(rootAbsPath, "HEAD"); err != nil {
			return fmt.Errorf("failed to update working tree: %w", err)
		}
	}

	// 8. Build derived branches.
	// REMOVED: We no longer build derived branches. Repo branches are patch-based and only contain user commits.
	// if err := rebuildDerivedBranches(rootAbsPath, newTip); err != nil {
	// 	return err
	// }

	log.Info().Msg("Successfully linked repositories")
	return nil
}

func validateLinkEnvironment(rootAbsPath string) error {
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return fmt.Errorf("not a git repository: %s", rootAbsPath)
	}
	if err := gitUtil.VerifyCleanState(rootAbsPath); err != nil {
		return fmt.Errorf("working tree is not clean: %w", err)
	}
	return nil
}

func applyRelationships(rootAbsPath, oldTip string, relationships map[string]string) (string, error) {
	// 5. Prepare updated metadata in temporary workspace
	tempDir, err := os.MkdirTemp("", "gitgroove-link-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tempDir) // cleanup

	// Create detached worktree at oldTip
	if err := gitUtil.WorktreeAddDetached(rootAbsPath, tempDir, oldTip); err != nil {
		return "", fmt.Errorf("failed to create temporary worktree: %w", err)
	}
	defer gitUtil.WorktreeRemove(rootAbsPath, tempDir) // cleanup worktree

	// Apply relationships
	// For each child -> parent:
	// 1. Write parent name to .gg/repos/<child>/parent
	// 2. Create empty file .gg/repos/<parent>/children/<child>
	for child, parent := range relationships {
		// Write parent pointer
		parentFile := filepath.Join(tempDir, ".gg", "repos", child, "parent")
		if err := os.WriteFile(parentFile, []byte(parent), 0644); err != nil {
			return "", fmt.Errorf("failed to write parent for %s: %w", child, err)
		}

		// Write child pointer in parent's folder
		childrenDir := filepath.Join(tempDir, ".gg", "repos", parent, "children")
		if err := os.MkdirAll(childrenDir, 0755); err != nil {
			return "", fmt.Errorf("failed to create children dir for %s: %w", parent, err)
		}
		childFile := filepath.Join(childrenDir, child)
		if err := os.WriteFile(childFile, []byte{}, 0644); err != nil {
			return "", fmt.Errorf("failed to write child entry %s in %s: %w", child, parent, err)
		}
	}

	// 6. Commit updated metadata
	if err := gitUtil.StagePath(tempDir, ".gg/repos"); err != nil {
		return "", fmt.Errorf("failed to stage .gg/repos: %w", err)
	}
	if err := gitUtil.Commit(tempDir, fmt.Sprintf("Link %d repositories", len(relationships))); err != nil {
		return "", fmt.Errorf("failed to commit metadata changes: %w", err)
	}
	newTip, err := gitUtil.GetHeadCommit(tempDir)
	if err != nil {
		return "", fmt.Errorf("failed to get new commit hash: %w", err)
	}
	return newTip, nil
}

func validateRelationships(root string, relationships map[string]string, existingRepos map[string]model.Repo) error {
	// 1. Check existence and validity
	if err := validateRelationshipExistence(root, relationships, existingRepos); err != nil {
		return err
	}

	// 2. Check for cycles using full graph
	if err := validateRelationshipCycles(relationships, existingRepos); err != nil {
		return err
	}

	return nil
}

func validateRelationshipExistence(root string, relationships map[string]string, existingRepos map[string]model.Repo) error {
	for child, parent := range relationships {
		childRepo, ok := existingRepos[child]
		if !ok {
			return fmt.Errorf("child repo '%s' not registered", child)
		}
		if _, ok := existingRepos[parent]; !ok {
			return fmt.Errorf("parent repo '%s' not registered", parent)
		}
		if child == parent {
			return fmt.Errorf("repo '%s' cannot be its own parent", child)
		}
		if childRepo.Parent != "" {
			return fmt.Errorf("repo '%s' already has a parent ('%s')", child, childRepo.Parent)
		}

		// Check dangling repo (child path must exist)
		childAbsPath := filepath.Join(root, childRepo.Path)
		if _, err := os.Stat(childAbsPath); err != nil {
			return fmt.Errorf("child repo '%s' path '%s' does not exist (dangling repo)", child, childRepo.Path)
		}
	}
	return nil
}

func validateRelationshipCycles(relationships map[string]string, existingRepos map[string]model.Repo) error {
	// Build graph: parent -> []children
	graph := make(map[string][]string)

	// Add existing edges
	for name, repo := range existingRepos {
		if repo.Parent != "" {
			graph[repo.Parent] = append(graph[repo.Parent], name)
		}
	}

	// Add new edges
	for child, parent := range relationships {
		graph[parent] = append(graph[parent], child)
	}

	// Detect cycles
	visited := make(map[string]bool)
	recursionStack := make(map[string]bool)

	var checkCycle func(current string) error
	checkCycle = func(current string) error {
		visited[current] = true
		recursionStack[current] = true

		for _, child := range graph[current] {
			if !visited[child] {
				if err := checkCycle(child); err != nil {
					return err
				}
			} else if recursionStack[child] {
				return fmt.Errorf("cycle detected involving '%s' and '%s'", current, child)
			}
		}

		recursionStack[current] = false
		return nil
	}

	// Check all nodes in the graph
	for node := range graph {
		if !visited[node] {
			if err := checkCycle(node); err != nil {
				return err
			}
		}
	}

	return nil
}


================================================================================================
FILE: core/internal/grove/checkout_test.go
================================================================================================

package grove_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
)

func TestCheckoutRepo(t *testing.T) {
	// Setup
	temp := t.TempDir()
	createDummyProject(t, temp)
	execGit(t, temp, "init")
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "initial commit")

	// Capture default branch
	defaultBranch := strings.TrimSpace(execGit(t, temp, "branch", "--show-current"))

	if err := grove.Init(temp); err != nil {
		t.Fatalf("Init failed: %v", err)
	}

	// Switch back to default branch
	execGit(t, temp, "checkout", defaultBranch)

	// Create directories for repos
	os.MkdirAll(filepath.Join(temp, "services", "parent"), 0755)
	os.MkdirAll(filepath.Join(temp, "services", "child"), 0755)

	// Register repos
	repos := map[string]string{
		"parent": "services/parent",
		"child":  "services/child",
	}
	if err := grove.Register(temp, repos); err != nil {
		t.Fatalf("Register failed: %v", err)
	}

	// Register creates .gitgroverepo files which are untracked.
	// We need to commit them to have a clean state for Link.
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "Add .gitgroverepo markers")

	// Link repos: parent -> child
	links := map[string]string{
		"child": "parent",
	}
	if err := grove.Link(temp, links); err != nil {
		t.Fatalf("Link failed: %v", err)
	}

	// Create a branch for the child repo
	branchName := "feature/checkout-test"
	if err := grove.CreateRepoBranch(temp, "child", branchName); err != nil {
		t.Fatalf("CreateRepoBranch failed: %v", err)
	}

	// Verify we are currently on default branch
	currentBranch := strings.TrimSpace(execGit(t, temp, "branch", "--show-current"))
	if currentBranch != defaultBranch {
		t.Fatalf("Expected to be on %s, got %s", defaultBranch, currentBranch)
	}

	// Test Case: Checkout the new branch
	if err := grove.CheckoutRepo(temp, "child", branchName); err != nil {
		t.Fatalf("CheckoutRepo failed: %v", err)
	}

	// Verify we switched to the correct branch
	// Expected branch name: gitgroove/repos/child/branches/feature/checkout-test
	expectedBranch := "gitgroove/repos/child/branches/feature/checkout-test"

	newBranch := strings.TrimSpace(execGit(t, temp, "branch", "--show-current"))
	if newBranch != expectedBranch {
		t.Errorf("Expected to be on branch %s, got %s", expectedBranch, newBranch)
	}
}


================================================================================================
FILE: core/internal/grove/switch.go
================================================================================================

package grove

import (
	"fmt"
	"strings"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove/model"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

/*
Switch moves the user's working tree to the GitGroove branch associated with the
specified repo and (optionally) branch name.

===========================================================
=                 HIGH-LEVEL RESPONSIBILITY               =
===========================================================

Switch:
  - First ensures the working tree is clean.
  - Then checks out the latest committed gitgroove/system branch to load
    authoritative metadata (.gg/repos).
  - Resolves the full ancestry chain of the requested repo.
  - Constructs the GitGroove repo branch ref:
    refs/heads/gitgroove/repos/<root/.../child>/branches/<branch>
  - Checks out the resolved branch.

Switch DOES NOT:
  - Modify metadata.
  - Create or rebuild derived branches.
  - Infer missing branches.
  - Touch project files except through standard git checkout.

===========================================================
=               MANDATORY PRE-STEP (CRITICAL)             =
===========================================================

Switch MUST always begin by checking out the latest gitgroove/system commit.

Reason:
  - All metadata lives ONLY on gitgroove/system.
  - Other working branches may not contain .gg/ at all.
  - Derived branch structures depend on committed hierarchy, not working state.
  - Guarantees deterministic behavior and prevents stale metadata usage.

Flow:
 1. Ensure working tree is clean.
 2. `git checkout gitgroove/system`
 3. Reload metadata from .gg/repos
 4. Continue Switch logic.

===========================================================
=                   BEHAVIORAL CONTRACT                    =
===========================================================

Given: Switch(repoName, branchName)

1. Preconditions:
  - Working tree must be clean.
  - Repo must exist in committed metadata.

2. Checkout system branch:
  - `git checkout gitgroove/system`
  - Ensures .gg/ is in correct, authoritative state.

3. Determine branch name:
  - Use "main" if branchName is empty.

4. Resolve ancestry chain:

  - Follow repo.parent → parent → ... → root.

  - Build path:
    <root>/<...>/<child>

    5. Construct fully-qualified GitGroove branch ref:
    refs/heads/gitgroove/repos/<path>/branches/<branchName>

6. Validate branch exists.

7. Checkout the branch:
  - Restore working tree to that isolated commit graph.

===========================================================
=                         GUARANTEES                       =
===========================================================

• Switch always uses fresh metadata (never stale .gg).
• No metadata is modified.
• No derived branches are created or rebuilt.
• Switch either fully succeeds or leaves the user on gitgroove/system.
• Repo ancestry resolution is always based on committed system state.
*/
func Switch(rootAbsPath, repoName, branch string) error {
	// 1. Validate environment
	if err := validateSwitchEnvironment(rootAbsPath); err != nil {
		return err
	}

	// 2. Checkout gitgroove/system to load authoritative metadata
	// This is CRITICAL: we must be on the system branch to read the correct .gg/ state.
	// We use "force" checkout? No, we already validated clean state.
	// Standard checkout is fine.
	log.Info().Msg("Checking out gitgroove/system to load metadata")
	if err := gitUtil.Checkout(rootAbsPath, "gitgroove/system"); err != nil {
		return fmt.Errorf("failed to checkout gitgroove/system: %w", err)
	}

	// 3. Load existing repos from the system branch (which is now HEAD)
	// We can use "HEAD" since we just checked it out.
	repos, err := loadExistingRepos(rootAbsPath, "HEAD")
	if err != nil {
		return fmt.Errorf("failed to load repos from system branch: %w", err)
	}

	// 4. Validate repo exists
	_, ok := repos[repoName]
	if !ok {
		return fmt.Errorf("repo '%s' not found in metadata", repoName)
	}

	// 5. Construct fully-qualified GitGroove branch ref
	// Default to "main" if branch is empty
	targetBranchName := branch
	if targetBranchName == "" {
		targetBranchName = model.DefaultRepoBranch
	}

	// New simplified branch naming: refs/heads/gitgroove/repos/<repoName>/branches/<branchName>
	fullBranchRef := RepoBranchRef(repoName, targetBranchName)

	// 6. Validate branch exists
	if !gitUtil.RefExists(rootAbsPath, fullBranchRef) {
		return fmt.Errorf("target branch '%s' does not exist", fullBranchRef)
	}

	// 7. Checkout the branch
	// We must use the short name to ensure we attach to the branch (avoid detached HEAD).
	shortBranchName := strings.TrimPrefix(fullBranchRef, "refs/heads/")
	log.Info().Msgf("Switching to %s", shortBranchName)
	if err := gitUtil.Checkout(rootAbsPath, shortBranchName); err != nil {
		return fmt.Errorf("failed to checkout target branch: %w", err)
	}

	log.Info().Msgf("Successfully switched to repo '%s' on branch '%s'", repoName, targetBranchName)
	return nil
}

func validateSwitchEnvironment(rootAbsPath string) error {
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return fmt.Errorf("not a git repository: %s", rootAbsPath)
	}
	if err := gitUtil.VerifyCleanState(rootAbsPath); err != nil {
		return fmt.Errorf("working tree is not clean: %w", err)
	}
	return nil
}


================================================================================================
FILE: core/internal/grove/init_test.go
================================================================================================

package grove_test

import (
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

// ------------------------------------------------------------
// HELPER: create dummy file structure
// ------------------------------------------------------------
func createDummyProject(t *testing.T, root string) {
	t.Helper()

	files := []string{
		"src/main.go",
		"src/utils/helper.go",
		"README.md",
		".gitignore",
		"config/app.yaml",
	}

	for _, f := range files {
		path := filepath.Join(root, f)
		if err := fileUtil.WriteTextFile(path, "// dummy content"); err != nil {
			t.Fatalf("failed to write dummy file %s: %v", f, err)
		}
	}
}

// ------------------------------------------------------------
// HELPER: run git inside test repo
// ------------------------------------------------------------
func execGit(t *testing.T, dir string, args ...string) string {
	t.Helper()
	cmd := exec.Command("git", args...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("git %v failed: %s", args, string(out))
	}
	return strings.TrimSpace(string(out))
}

// ------------------------------------------------------------
// Test 1: Init should succeed when repo is clean & initialized
// ------------------------------------------------------------
func TestInitOnCleanRepo(t *testing.T) {
	temp := t.TempDir()

	// Create dummy files
	createDummyProject(t, temp)

	// git init manually (Init() no longer does this)
	execGit(t, temp, "init")
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "initial commit")

	// Sanity check
	if !gitUtil.IsInsideGitRepo(temp) {
		t.Fatalf("repo not initialized")
	}

	// Make sure repo is clean
	if err := gitUtil.VerifyCleanState(temp); err != nil {
		t.Fatalf("repo not clean before init: %v", err)
	}

	// Run GitGroove init
	if err := grove.Init(temp); err != nil {
		t.Fatalf("Init() failed on clean repo: %v", err)
	}

	// Verify .gg exists
	if !fileUtil.Exists(filepath.Join(temp, ".gg")) {
		t.Fatalf(".gg directory missing after init")
	}

	// Verify .gg/repos exists
	if !fileUtil.Exists(filepath.Join(temp, ".gg/repos")) {
		t.Fatalf(".gg/repos directory missing after init")
	}

	// Verify .gitkeep exists
	if !fileUtil.Exists(filepath.Join(temp, ".gg/repos/.gitkeep")) {
		t.Fatalf(".gg/repos/.gitkeep missing after init")
	}

	// Verify system branch exists
	exists, err := gitUtil.HasBranch(temp, "gitgroove/system")
	if err != nil || !exists {
		t.Fatalf("gitgroove/system branch missing")
	}

	// Verify HEAD is on system branch
	head := execGit(t, temp, "branch", "--show-current")
	if head != "gitgroove/system" {
		t.Fatalf("expected HEAD on gitgroove/system, got %s", head)
	}

	// Metadata should be committed
	count := gitLogCount(t, temp)
	if count != 2 { // initial commit + system commit
		t.Fatalf("expected 2 commits, got %d", count)
	}
}

// ------------------------------------------------------------
// Test 2: Init should fail when git repo does NOT exist
// ------------------------------------------------------------
func TestInitFailsOnNoGitRepo(t *testing.T) {
	temp := t.TempDir()

	createDummyProject(t, temp)

	if gitUtil.IsInsideGitRepo(temp) {
		t.Fatalf("temp unexpectedly inside git repo")
	}

	err := grove.Init(temp)
	if err == nil {
		t.Fatalf("Init() should have failed on non-git directory")
	}
}

// ------------------------------------------------------------
// Test 3: Init should fail on dirty repo
// ------------------------------------------------------------
func TestInitFailsOnDirtyRepo(t *testing.T) {
	temp := t.TempDir()

	// Create dummy files
	createDummyProject(t, temp)

	// initialize git
	execGit(t, temp, "init")

	// DO NOT COMMIT — repo becomes dirty
	execGit(t, temp, "add", ".") // staged
	// Or: leave untracked files

	err := grove.Init(temp)
	if err == nil {
		t.Fatalf("Init() should fail on dirty repo")
	}
}

// ------------------------------------------------------------
// Helper: count commits
// ------------------------------------------------------------
func gitLogCount(t *testing.T, dir string) int {
	out := execGit(t, dir, "rev-list", "--count", "HEAD")
	n, err := strconv.Atoi(out)
	if err != nil {
		t.Fatalf("invalid commit count: %v", err)
	}
	return n
}


================================================================================================
FILE: core/internal/grove/register_test.go
================================================================================================

package grove_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

func TestRegister(t *testing.T) {
	// Setup
	temp := t.TempDir()
	createDummyProject(t, temp)
	execGit(t, temp, "init")
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "initial commit")

	if err := grove.Init(temp); err != nil {
		t.Fatalf("Init failed: %v", err)
	}

	// Create directories for repos
	os.MkdirAll(filepath.Join(temp, "backend"), 0755)
	os.MkdirAll(filepath.Join(temp, "frontend"), 0755)

	// Test Case 1: Successful Registration
	repos := map[string]string{
		"backend":  "backend",
		"frontend": "frontend",
	}
	if err := grove.Register(temp, repos); err != nil {
		t.Fatalf("Register failed: %v", err)
	}

	// Verify .gg/repos content
	// Check backend repo
	backendPathContent, err := gitUtil.ShowFile(temp, "gitgroove/system", ".gg/repos/backend/path")
	if err != nil {
		t.Fatalf("failed to read backend path: %v", err)
	}
	if strings.TrimSpace(backendPathContent) != "backend" {
		t.Errorf("expected backend path 'backend', got '%s'", backendPathContent)
	}

	// Check frontend repo
	frontendPathContent, err := gitUtil.ShowFile(temp, "gitgroove/system", ".gg/repos/frontend/path")
	if err != nil {
		t.Fatalf("failed to read frontend path: %v", err)
	}
	if strings.TrimSpace(frontendPathContent) != "frontend" {
		t.Errorf("expected frontend path 'frontend', got '%s'", frontendPathContent)
	}

	// Test Case 2: Duplicate Name
	err = grove.Register(temp, map[string]string{"backend": "other"})
	if err == nil {
		t.Fatal("expected error for duplicate name, got nil")
	}

	// Test Case 3: Duplicate Path
	os.MkdirAll(filepath.Join(temp, "other"), 0755)
	err = grove.Register(temp, map[string]string{"other": "backend"})
	if err == nil {
		t.Fatal("expected error for duplicate path, got nil")
	}

	// Test Case 4: Non-existent Path
	err = grove.Register(temp, map[string]string{"ghost": "ghost"})
	if err == nil {
		t.Fatal("expected error for non-existent path, got nil")
	}

	// Test Case 5: Nested .git
	os.MkdirAll(filepath.Join(temp, "nested"), 0755)
	os.MkdirAll(filepath.Join(temp, "nested", ".git"), 0755)
	err = grove.Register(temp, map[string]string{"nested": "nested"})
	if err == nil {
		t.Fatal("expected error for nested .git, got nil")
	}
}


================================================================================================
FILE: core/internal/grove/branch.go
================================================================================================

package grove

import (
	"fmt"

	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

// CreateRepoBranch creates a new branch for a specific nested repository.
//
// The branch path structure is:
// gitgroove/repos/<a>/children/<b>/branches/<branchName>
//
// This function:
// 1. Validates the environment.
// 2. Loads existing repos from gitgroove/system.
// 3. Constructs the ancestry chain for the target repo.
// 4. Creates the branch ref pointing to the current project HEAD.
func CreateRepoBranch(rootAbsPath, repoName, branchName string) error {
	log.Info().Msgf("Attempting to create branch '%s' for repo '%s'", branchName, repoName)

	// 1. Validate environment
	// Reuse validateLinkEnvironment as it checks for clean state and git repo
	if err := validateLinkEnvironment(rootAbsPath); err != nil {
		return err
	}

	// 2. Read latest gitgroove/system commit
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		return fmt.Errorf("failed to resolve %s (is GitGroove initialized?): %w", systemRef, err)
	}

	// 3. Load existing repo metadata
	existingRepos, err := loadExistingRepos(rootAbsPath, oldTip)
	if err != nil {
		return fmt.Errorf("failed to load existing repos: %w", err)
	}

	// 4. Find target repo
	_, ok := existingRepos[repoName]
	if !ok {
		return fmt.Errorf("repo '%s' not found", repoName)
	}

	// 5. Construct branch ref path
	// New simplified branch naming: refs/heads/gitgroove/repos/<repoName>/branches/<branchName>
	fullRefPath := RepoBranchRef(repoName, branchName)

	// 6. Get HEAD commit
	headCommit, err := gitUtil.GetHeadCommit(rootAbsPath)
	if err != nil {
		return fmt.Errorf("failed to get project HEAD: %w", err)
	}

	// 7. Create the branch ref
	log.Info().Msgf("Creating branch ref: %s -> %s", fullRefPath, headCommit)
	if err := gitUtil.SetRef(rootAbsPath, fullRefPath, headCommit); err != nil {
		return fmt.Errorf("failed to create branch ref: %w", err)
	}

	return nil
}


================================================================================================
FILE: core/internal/grove/doctor/repo_doctor.go
================================================================================================

package doctor

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove/model"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

type RepoState struct {
	Repo       model.Repo
	PathExists bool
}

type RepoDoctor struct {
	Repos map[string]RepoState
}

func GetRepoDoctor(rootAbsPath string) (*RepoDoctor, error) {
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		// If system branch doesn't exist, we assume no repos registered or not init
		return &RepoDoctor{Repos: map[string]RepoState{}}, nil
	}

	repos, err := loadRepos(rootAbsPath, oldTip)
	if err != nil {
		return nil, err
	}

	repoStates := make(map[string]RepoState)
	for name, repo := range repos {
		absPath := filepath.Join(rootAbsPath, repo.Path)
		exists := false
		if info, err := os.Stat(absPath); err == nil && info.IsDir() {
			exists = true
		}
		repoStates[name] = RepoState{
			Repo:       repo,
			PathExists: exists,
		}
	}

	return &RepoDoctor{Repos: repoStates}, nil
}

// loadRepos is a helper to load repo metadata from a specific commit.
func loadRepos(root, ref string) (map[string]model.Repo, error) {
	entries, err := gitUtil.ListTree(root, ref, ".gg/repos")
	if err != nil {
		// Likely empty or doesn't exist
		return map[string]model.Repo{}, nil
	}

	repos := make(map[string]model.Repo)
	for _, name := range entries {
		if name == ".gitkeep" {
			continue
		}

		pathFile := fmt.Sprintf(".gg/repos/%s/path", name)
		content, err := gitUtil.ShowFile(root, ref, pathFile)
		if err != nil {
			return nil, fmt.Errorf("failed to read path for repo %s: %w", name, err)
		}
		repoPath := strings.TrimSpace(content)

		parentFile := fmt.Sprintf(".gg/repos/%s/parent", name)
		parentContent, err := gitUtil.ShowFile(root, ref, parentFile)
		parent := ""
		if err == nil {
			parent = strings.TrimSpace(parentContent)
		}

		repos[name] = model.Repo{
			Name:   name,
			Path:   repoPath,
			Parent: parent,
		}
	}
	return repos, nil
}


================================================================================================
FILE: core/internal/grove/doctor/basic_doctor.go
================================================================================================

package doctor

import (
	"fmt"
	"strings"

	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

type BasicDoctor struct {
	RootPath      string
	CurrentBranch string
	IsClean       bool
	SystemCommit  string
}

func GetBasicDoctor(rootAbsPath string) (*BasicDoctor, error) {
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return nil, fmt.Errorf("not a git repository: %s", rootAbsPath)
	}

	branch, err := gitUtil.GetCurrentBranch(rootAbsPath)
	if err != nil {
		return nil, fmt.Errorf("failed to get current branch: %w", err)
	}

	isClean := true
	if err := gitUtil.VerifyCleanState(rootAbsPath); err != nil {
		isClean = false
	}

	systemRef := "refs/heads/gitgroove/system"
	systemCommit, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		systemCommit = "not initialized"
	}

	return &BasicDoctor{
		RootPath:      rootAbsPath,
		CurrentBranch: strings.TrimSpace(branch), // Changed from 'branch' to 'strings.TrimSpace(branch)' and fixed variable name
		IsClean:       isClean,
		SystemCommit:  systemCommit,
	}, nil
}


================================================================================================
FILE: core/internal/grove/doctor/doctor.go
================================================================================================

package doctor

import (
	"fmt"
	"strings"
)

type Doctor struct {
	Basic *BasicDoctor
	Repos *RepoDoctor
	Links *LinkDoctor
}

func GetDoctor(rootAbsPath string) (*Doctor, error) {
	basic, err := GetBasicDoctor(rootAbsPath)
	if err != nil {
		return nil, fmt.Errorf("failed to get basic doctor: %w", err)
	}

	repos, err := GetRepoDoctor(rootAbsPath)
	if err != nil {
		return nil, fmt.Errorf("failed to get repo doctor: %w", err)
	}

	links := GetLinkDoctor(repos)

	return &Doctor{
		Basic: basic,
		Repos: repos,
		Links: links,
	}, nil
}

func (d *Doctor) String() string {
	var sb strings.Builder

	sb.WriteString("GitGrove Doctor\n")
	sb.WriteString("===============\n\n")

	sb.WriteString(fmt.Sprintf("Root:   %s\n", d.Basic.RootPath))
	sb.WriteString(fmt.Sprintf("Branch: %s\n", d.Basic.CurrentBranch))
	cleanState := "Clean"
	if !d.Basic.IsClean {
		cleanState = "Dirty"
	}
	sb.WriteString(fmt.Sprintf("State:  %s\n", cleanState))
	sb.WriteString(fmt.Sprintf("System: %s\n\n", d.Basic.SystemCommit))

	sb.WriteString("Registered Repositories:\n")
	sb.WriteString("------------------------\n")
	if len(d.Repos.Repos) == 0 {
		sb.WriteString("(none)\n")
	} else {
		sb.WriteString(d.Links.String())
	}

	return sb.String()
}


================================================================================================
FILE: core/internal/grove/doctor/link_doctor.go
================================================================================================

package doctor

import (
	"fmt"
	"sort"
	"strings"
)

// LinkDoctor represents the hierarchical structure of repositories.
type LinkDoctor struct {
	Roots []*TreeNode
}

// TreeNode represents a single repository in the hierarchy.
type TreeNode struct {
	State    RepoState
	Children []*TreeNode
}

// GetLinkDoctor builds the hierarchical structure of repositories from a RepoDoctor.
func GetLinkDoctor(repoDoctor *RepoDoctor) *LinkDoctor {
	// Build map of name -> node
	nodes := make(map[string]*TreeNode)
	for name, state := range repoDoctor.Repos {
		nodes[name] = &TreeNode{
			State:    state,
			Children: []*TreeNode{},
		}
	}

	// Link children to parents
	var roots []*TreeNode
	for _, node := range nodes {
		if node.State.Repo.Parent == "" {
			roots = append(roots, node)
		} else {
			if parent, ok := nodes[node.State.Repo.Parent]; ok {
				parent.Children = append(parent.Children, node)
			} else {
				// Parent missing from map (should not happen if consistent)
				// Treat as root for display purposes, maybe mark as broken link?
				// For now, just append to roots so it's visible.
				roots = append(roots, node)
			}
		}
	}

	// Sort roots and children for consistent output
	sortNodes(roots)
	for _, node := range nodes {
		sortNodes(node.Children)
	}

	return &LinkDoctor{Roots: roots}
}

func sortNodes(nodes []*TreeNode) {
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].State.Repo.Name < nodes[j].State.Repo.Name
	})
}

// String returns a beautiful tree representation of the hierarchy
func (ld *LinkDoctor) String() string {
	var sb strings.Builder
	for _, root := range ld.Roots {
		ld.printNode(&sb, root, "", true)
	}
	return sb.String()
}

func (ld *LinkDoctor) printNode(sb *strings.Builder, node *TreeNode, prefix string, isLast bool) {
	sb.WriteString(prefix)
	if isLast {
		sb.WriteString("└── ")
		prefix += "    "
	} else {
		sb.WriteString("├── ")
		prefix += "│   "
	}

	sb.WriteString(fmt.Sprintf("%s (%s)", node.State.Repo.Name, node.State.Repo.Path))

	if !node.State.PathExists {
		sb.WriteString(" [MISSING]")
	}

	// Check for broken parent link (if parent is set but not found in tree logic)
	// The tree construction logic puts orphans in roots.
	// We can check if it has a parent defined but is at root level (and not empty parent)
	// However, the recursion doesn't know if it's a root because of logic or definition.
	// A simpler check: if we are printing a node, we can check its parent field.
	// But we don't have easy access to the parent node here to check if it exists.
	// The GetLinkStatus logic handles the structure.
	// If a node claims a parent "foo" but "foo" doesn't exist, it ends up as a root.
	// We can detect that case if we want, but "MISSING" path is the main request.

	sb.WriteString("\n")

	for i, child := range node.Children {
		ld.printNode(sb, child, prefix, i == len(node.Children)-1)
	}
}


================================================================================================
FILE: core/internal/grove/commit.go
================================================================================================

package grove

import (
	"fmt"
	"path/filepath"
	"strings"

	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

// Commit performs a commit with strict GitGrove validations.
//
// It ensures:
// 1. We are inside a git repo.
// 2. We are on a valid GitGrove repo branch.
// 3. The .gitgroverepo marker matches the repo identity derived from the branch.
// 4. All staged changes belong strictly to this repo (no nested repos, no .gg metadata).
// 5. Delegates to `git commit`.
func Commit(rootAbsPath, message string) error {
	// 1. Verify inside git repo
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return fmt.Errorf("not a git repository: %s", rootAbsPath)
	}

	// 2. Verify we are on a GitGrove repo branch
	currentBranch, err := gitUtil.GetCurrentBranch(rootAbsPath)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	// 3. Extract repo name from branch
	targetRepoName, err := ParseRepoFromBranch(currentBranch)
	if err != nil {
		return err
	}

	// 4. Load metadata from gitgroove/system (WITHOUT checkout)
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		return fmt.Errorf("failed to resolve %s: %w", systemRef, err)
	}

	repos, err := loadExistingRepos(rootAbsPath, oldTip)
	if err != nil {
		return fmt.Errorf("failed to load repo metadata: %w", err)
	}

	targetRepo, ok := repos[targetRepoName]
	if !ok {
		return fmt.Errorf("current branch belongs to unknown repo '%s'", targetRepoName)
	}

	targetRepoAbsPath := filepath.Join(rootAbsPath, targetRepo.Path)

	// 5. Validate .gitgroverepo identity
	markerPath := filepath.Join(targetRepoAbsPath, ".gitgroverepo")
	if !fileUtil.Exists(markerPath) {
		return fmt.Errorf("repo marker not found at %s (is this a valid GitGrove repo?)", markerPath)
	}

	markerContent, err := fileUtil.ReadTextFile(markerPath)
	if err != nil {
		return fmt.Errorf("failed to read repo marker: %w", err)
	}

	markerIdentity := strings.TrimSpace(markerContent)
	if markerIdentity != targetRepoName {
		return fmt.Errorf("repo identity mismatch: branch expects '%s', but marker says '%s'", targetRepoName, markerIdentity)
	}

	// 6. Validate staged changes belong to this repo
	// git diff --cached --name-only
	stagedFilesStr, err := gitUtil.RunGit(rootAbsPath, "diff", "--cached", "--name-only")
	if err != nil {
		return fmt.Errorf("failed to get staged changes: %w", err)
	}

	if stagedFilesStr == "" {
		return fmt.Errorf("nothing to commit (staged changes empty)")
	}

	stagedFiles := strings.Split(strings.TrimSpace(stagedFilesStr), "\n")
	for _, file := range stagedFiles {
		if file == "" {
			continue
		}

		absFile := filepath.Join(rootAbsPath, file)

		// Ensure file is inside repo root (targetRepoAbsPath)
		rel, err := filepath.Rel(targetRepoAbsPath, absFile)
		if err != nil || strings.HasPrefix(rel, "..") || strings.HasPrefix(rel, "/") {
			return fmt.Errorf("staged file '%s' is outside the current repository scope (%s)", file, targetRepoName)
		}

		// Ensure file is NOT inside nested repo
		if err := checkNestedRepo(targetRepoAbsPath, absFile); err != nil {
			return fmt.Errorf("staged file '%s' violates nested repo boundary: %w", file, err)
		}

		// Ensure not .gg/**
		relToRoot, _ := filepath.Rel(rootAbsPath, absFile)
		if strings.HasPrefix(relToRoot, ".gg/") || relToRoot == ".gg" {
			return fmt.Errorf("cannot commit GitGroove metadata: %s", relToRoot)
		}
	}

	// 7. Perform the commit
	log.Info().Msgf("Committing changes to repo '%s' on branch '%s'", targetRepoName, currentBranch)
	if err := gitUtil.Commit(rootAbsPath, message); err != nil {
		return fmt.Errorf("git commit failed: %w", err)
	}

	return nil
}


================================================================================================
FILE: core/internal/grove/move_test.go
================================================================================================

package grove_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

func TestMove(t *testing.T) {
	// Setup
	temp := t.TempDir()
	createDummyProject(t, temp)
	execGit(t, temp, "init")
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "initial commit")

	// Capture default branch
	defaultBranch := strings.TrimSpace(execGit(t, temp, "branch", "--show-current"))

	if err := grove.Init(temp); err != nil {
		t.Fatalf("Init failed: %v", err)
	}

	execGit(t, temp, "checkout", defaultBranch)

	// Register repo
	os.MkdirAll(filepath.Join(temp, "backend"), 0755)
	repos := map[string]string{
		"backend": "backend",
	}
	if err := grove.Register(temp, repos); err != nil {
		t.Fatalf("Register failed: %v", err)
	}

	// Commit markers
	execGit(t, temp, "add", ".")
	execGit(t, temp, "commit", "-m", "Add markers")

	// Move backend to services/backend
	newPath := "services/backend"
	if err := grove.Move(temp, "backend", newPath); err != nil {
		t.Fatalf("Move failed: %v", err)
	}

	// Verify physical move
	if _, err := os.Stat(filepath.Join(temp, newPath)); err != nil {
		t.Errorf("expected directory at %s, got error: %v", newPath, err)
	}
	if _, err := os.Stat(filepath.Join(temp, "backend")); err == nil {
		t.Errorf("expected directory at backend to be gone")
	}

	// Verify metadata
	pathContent, err := gitUtil.ShowFile(temp, "gitgroove/system", ".gg/repos/backend/path")
	if err != nil {
		t.Fatalf("failed to read metadata: %v", err)
	}
	if strings.TrimSpace(pathContent) != newPath {
		t.Errorf("expected path '%s', got '%s'", newPath, pathContent)
	}

	// Verify repo branch still exists and is accessible
	// It should be unchanged
	branchRef := "refs/heads/gitgroove/repos/backend/branches/main"
	if exists, _ := gitUtil.HasBranch(temp, branchRef); !exists {
		t.Errorf("expected repo branch %s to exist", branchRef)
	}
}


================================================================================================
FILE: core/internal/grove/move.go
================================================================================================

package grove

import (
	"fmt"
	"os"
	"path/filepath"

	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

/*
Move relocates a registered repository to a new path within the project.

It operates atomically on the gitgroove/system branch to update metadata,
and physically moves the directory on disk.

High-Level Responsibility:
  - Validates environment and inputs.
  - Checks out gitgroove/system to load authoritative metadata.
  - Verifies repo existence and new path availability.
  - Moves the directory on disk.
  - Updates .gg/repos/<name>/path.
  - Commits the change to gitgroove/system.

Guarantees:
  - Atomic metadata update.
  - Preserves repo identity (name and branch remain unchanged).
  - Does NOT rebuild branches (Option B architecture).
*/
func Move(rootAbsPath, repoName, newRelPath string) error {
	log.Info().Msgf("Attempting to move repo '%s' to '%s'", repoName, newRelPath)

	// 1. Validate environment
	if err := validateMoveEnvironment(rootAbsPath); err != nil {
		return err
	}

	// 2. Resolve gitgroove/system ref
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		return fmt.Errorf("failed to resolve %s: %w", systemRef, err)
	}

	// 3. Load existing repos from system ref
	repos, err := loadExistingRepos(rootAbsPath, oldTip)
	if err != nil {
		return fmt.Errorf("failed to load repos: %w", err)
	}

	// 4. Validate move operation
	repo, ok := repos[repoName]
	if !ok {
		return fmt.Errorf("repo '%s' not found", repoName)
	}

	// Normalize new path
	newRelPath = fileUtil.NormalizePath(newRelPath)
	if newRelPath == "" || newRelPath == "." || newRelPath == "/" {
		return fmt.Errorf("invalid destination path '%s'", newRelPath)
	}

	// Check if new path is already taken by another repo
	for _, r := range repos {
		if r.Path == newRelPath {
			return fmt.Errorf("path '%s' is already used by repo '%s'", newRelPath, r.Name)
		}
	}

	// Check if new path exists on disk (unless it's the same as old path, which is a no-op)
	if repo.Path == newRelPath {
		log.Info().Msg("Source and destination paths are identical. Nothing to do.")
		return nil
	}

	oldAbsPath := filepath.Join(rootAbsPath, repo.Path)
	newAbsPath := filepath.Join(rootAbsPath, newRelPath)

	if _, err := os.Stat(newAbsPath); err == nil {
		return fmt.Errorf("destination path '%s' already exists", newRelPath)
	}

	// 5. Perform physical move
	// Ensure parent dir of new path exists
	parentDir := filepath.Dir(newAbsPath)
	if err := os.MkdirAll(parentDir, 0755); err != nil {
		return fmt.Errorf("failed to create parent directory '%s': %w", parentDir, err)
	}

	log.Info().Msgf("Moving directory from '%s' to '%s'", repo.Path, newRelPath)
	if err := os.Rename(oldAbsPath, newAbsPath); err != nil {
		return fmt.Errorf("failed to move directory: %w", err)
	}

	// 6. Update metadata using temp worktree
	newTip, err := updateRepoPathInSystem(rootAbsPath, oldTip, repoName, newRelPath)
	if err != nil {
		// Attempt rollback of physical move
		_ = os.Rename(newAbsPath, oldAbsPath)
		return fmt.Errorf("failed to update metadata: %w", err)
	}

	// 7. Atomically update gitgroove/system
	if err := gitUtil.UpdateRef(rootAbsPath, systemRef, newTip, oldTip); err != nil {
		// Attempt rollback of physical move
		_ = os.Rename(newAbsPath, oldAbsPath)
		return fmt.Errorf("failed to update %s (concurrent modification?): %w", systemRef, err)
	}

	log.Info().Msg("Successfully moved repository")
	return nil
}

func updateRepoPathInSystem(rootAbsPath, oldTip, repoName, newPath string) (string, error) {
	tempDir, err := os.MkdirTemp("", "gitgroove-move-*")
	if err != nil {
		return "", fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tempDir)

	if err := gitUtil.WorktreeAddDetached(rootAbsPath, tempDir, oldTip); err != nil {
		return "", fmt.Errorf("failed to create temporary worktree: %w", err)
	}
	defer gitUtil.WorktreeRemove(rootAbsPath, tempDir)

	// Update path file
	pathFile := filepath.Join(tempDir, ".gg", "repos", repoName, "path")
	if err := os.MkdirAll(filepath.Dir(pathFile), 0755); err != nil {
		return "", fmt.Errorf("failed to create repo metadata dir: %w", err)
	}
	if err := os.WriteFile(pathFile, []byte(newPath), 0644); err != nil {
		return "", fmt.Errorf("failed to write new path: %w", err)
	}

	// Commit
	if err := gitUtil.StagePath(tempDir, ".gg/repos"); err != nil {
		return "", fmt.Errorf("failed to stage metadata: %w", err)
	}
	if err := gitUtil.Commit(tempDir, fmt.Sprintf("Move repo '%s' to '%s'", repoName, newPath)); err != nil {
		return "", fmt.Errorf("failed to commit move: %w", err)
	}

	return gitUtil.GetHeadCommit(tempDir)
}

func validateMoveEnvironment(rootAbsPath string) error {
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return fmt.Errorf("not a git repository: %s", rootAbsPath)
	}
	if err := gitUtil.VerifyCleanState(rootAbsPath); err != nil {
		return fmt.Errorf("working tree is not clean: %w", err)
	}
	return nil
}


================================================================================================
FILE: core/internal/grove/checkout.go
================================================================================================

package grove

import (
	"fmt"

	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

// CheckoutRepo switches the user's working tree to a specific branch of a nested repository.
//
// It supports the branch path structure:
// gitgroove/repos/<a>/children/<b>/branches/<branchName>
func CheckoutRepo(rootAbsPath, repoName, branchName string) error {
	// 1. Validate environment
	if err := validateSwitchEnvironment(rootAbsPath); err != nil {
		return err
	}

	// 2. Checkout gitgroove/system to load authoritative metadata
	log.Info().Msg("Checking out gitgroove/system to load metadata")
	if err := gitUtil.Checkout(rootAbsPath, "gitgroove/system"); err != nil {
		return fmt.Errorf("failed to checkout gitgroove/system: %w", err)
	}

	// 3. Load existing repos from the system branch
	repos, err := loadExistingRepos(rootAbsPath, "HEAD")
	if err != nil {
		return fmt.Errorf("failed to load repos from system branch: %w", err)
	}

	// 4. Find target repo
	_, ok := repos[repoName]
	if !ok {
		return fmt.Errorf("repo '%s' not found in metadata", repoName)
	}

	// 5. Construct branch ref path
	// New simplified branch naming: refs/heads/gitgroove/repos/<repoName>/branches/<branchName>
	fullRefPath := RepoBranchRef(repoName, branchName)

	// 6. Validate branch exists
	if !gitUtil.RefExists(rootAbsPath, fullRefPath) {
		return fmt.Errorf("target branch '%s' does not exist", fullRefPath)
	}

	// 7. Checkout the branch
	// We use the short name (without refs/heads/) to attach to the branch
	shortBranchName := RepoBranchShortFromRef(fullRefPath)
	log.Info().Msgf("Switching to %s", shortBranchName)
	if err := gitUtil.Checkout(rootAbsPath, shortBranchName); err != nil {
		return fmt.Errorf("failed to checkout target branch: %w", err)
	}

	log.Info().Msgf("Successfully switched to repo '%s' on branch '%s'", repoName, branchName)
	return nil
}


================================================================================================
FILE: core/internal/grove/model/model.go
================================================================================================

package model

// Repo represents a repository registered in GitGroove.
//
// This struct is serialized to JSON and stored in .gg/repos/<name>/path (currently just path string,
// but this model supports future extensibility).
//
// Usage:
//   - Loaded from .gg/repos during Init/Register/List operations.
//   - Used to map logical names to physical paths.
type Repo struct {
	// Name is the unique identifier for the repo (e.g. "backend", "frontend").
	// It must be unique within the GitGroove project.
	Name string `json:"name"`

	// Path is the relative path from the GitGroove root to the repo root.
	// It uses forward slashes ("/") as separators.
	Path string `json:"path"`

	// Parent is the name of the parent repository in the hierarchy.
	// Empty if it's a root repository.
	Parent string `json:"parent,omitempty"`
}

const DefaultRepoBranch = "main"


================================================================================================
FILE: core/internal/grove/init.go
================================================================================================

package grove

import (
	"fmt"
	"path/filepath"

	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
	"github.com/rs/zerolog/log"
)

// Init initializes GitGroove on the current Git repository.
//
// High-level behavior:
//
//	Init bootstraps the GitGroove metadata structure within an existing Git repository.
//	It creates the hidden .gg directory, initializes the .gg/repos structure, and establishes
//	the detached gitgroove/system branch to track metadata history.
//
// Requirements / invariants:
//   - absolutePath must point to a valid, existing Git repository.
//   - The repository working tree must be 100% clean (no staged, unstaged, or untracked changes)
//     to ensure safe branch creation and switching.
//   - The .gg directory must not already exist (idempotency check).
//   - The gitgroove/system branch must not already exist.
//
// Step-by-step algorithm:
//
//  1. Validate environment:
//     • Normalize the path.
//     • Verify it is a Git repository.
//     • Verify the working tree is clean.
//     • Verify .gg does not exist.
//     • Verify gitgroove/system branch does not exist.
//     If any check fails → abort immediately.
//
//  2. Create metadata directory structure:
//     • Create .gg directory.
//     • Create .gg/repos directory.
//     • Create .gg/repos/.gitkeep to ensure git tracks the directory even if empty.
//
//  3. Initialize system branch:
//     • Create and checkout a new orphan-like branch 'gitgroove/system'.
//     (Note: In this implementation, it branches off the current HEAD, effectively making
//     history shared until this point, or it might be intended as an orphan.
//     The current implementation uses `checkout -b`, which branches from current HEAD.)
//
//  4. Commit initial state:
//     • Stage the .gg directory.
//     • Commit with message "Initialize GitGroove system branch".
//
//  5. Result:
//     • The user is left on the gitgroove/system branch (based on current implementation).
//     • .gg exists and is tracked.
//
// Atomicity:
//   - This operation is not fully atomic in the ACID sense (filesystem changes happen before git ops).
//   - However, checks are performed upfront to minimize failure risk.
//   - If it fails midway, the user might be left with a partial .gg directory or a new branch.
func Init(absolutePath string) error {
	log.Debug().Msg("Attempting to initialize GitGroove in path " + absolutePath)

	// Normalize
	absolutePath = fileUtil.NormalizePath(absolutePath)
	ggPath := filepath.Join(absolutePath, ".gg")

	if err := validateInitEnvironment(absolutePath, ggPath); err != nil {
		return err
	}

	fmt.Println("Initializing GitGroove in", absolutePath)

	if err := createMetadataDirectories(ggPath); err != nil {
		return err
	}

	if err := initializeSystemBranch(absolutePath); err != nil {
		return err
	}

	log.Info().Msg("GitGroove initialized successfully")

	return nil
}

func validateInitEnvironment(absolutePath, ggPath string) error {
	// MUST be an existing git repo
	if !git.IsInsideGitRepo(absolutePath) {
		return fmt.Errorf("GitGroove cannot initialize: not a valid Git repository")
	}

	// MUST be clean
	if err := git.VerifyCleanState(absolutePath); err != nil {
		return fmt.Errorf("GitGroove cannot initialize: %w", err)
	}

	// .gg must NOT exist
	if err := fileUtil.EnsureNotExists(ggPath); err != nil {
		return fmt.Errorf("GitGroove already initialized: %w", err)
	}

	// Ensure system branch does NOT already exist
	exists, err := git.HasBranch(absolutePath, "gitgroove/system")
	if err != nil {
		return fmt.Errorf("failed checking system branch: %w", err)
	}
	if exists {
		return fmt.Errorf("gitgroove/system branch already exists — GitGroove may already be initialized")
	}
	return nil
}

func createMetadataDirectories(ggPath string) error {
	// Create .gg
	if err := fileUtil.CreateDir(ggPath); err != nil {
		return fmt.Errorf("failed to create .gg: %w", err)
	}
	log.Info().Msg("Created .gg workspace directory")

	// Create .gg/repos
	reposPath := filepath.Join(ggPath, "repos")
	if err := fileUtil.CreateDir(reposPath); err != nil {
		return fmt.Errorf("failed to create .gg/repos: %w", err)
	}
	log.Info().Msg("Created .gg/repos directory")

	// Create .gitkeep to ensure repos dir is tracked
	gitKeepFile := filepath.Join(reposPath, ".gitkeep")
	if err := fileUtil.WriteTextFile(gitKeepFile, ""); err != nil {
		return fmt.Errorf("failed to create .gitkeep: %w", err)
	}
	return nil
}

func initializeSystemBranch(absolutePath string) error {
	// Create and checkout system branch
	if err := git.CreateAndCheckoutBranch(absolutePath, "gitgroove/system"); err != nil {
		return fmt.Errorf("failed creating system branch: %w", err)
	}

	// Stage .gg
	if err := git.StagePath(absolutePath, ".gg"); err != nil {
		return fmt.Errorf("failed staging .gg: %w", err)
	}

	// Commit
	if err := git.Commit(absolutePath, "Initialize GitGroove system branch"); err != nil {
		return fmt.Errorf("failed committing metadata: %w", err)
	}
	return nil
}


================================================================================================
FILE: core/internal/grove/stage.go
================================================================================================

package grove

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove/model"
	fileUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/file"
	gitUtil "github.com/kuchuk-borom-debbarma/GitGrove/core/internal/util/git"
)

// Stage adds file contents to the staging area, with GitGrove-specific validations.
//
// It ensures that:
// 1. We are inside a valid Git repository.
// 2. We are on a valid GitGrove repo branch (gitgroove/repos/...).
// 3. The files exist and are within the SPECIFIC repository bound to the current branch.
// 4. The files do NOT belong to a nested GitGrove repository.
func Stage(rootAbsPath string, files []string) error {
	if !gitUtil.IsInsideGitRepo(rootAbsPath) {
		return fmt.Errorf("not a git repository: %s", rootAbsPath)
	}

	// 1. Get current branch and validate it's a GitGrove repo branch
	currentBranch, err := gitUtil.GetCurrentBranch(rootAbsPath)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	// Expected format: gitgroove/repos/<repoName>/branches/<branchName>
	targetRepoName, err := ParseRepoFromBranch(currentBranch)
	if err != nil {
		return err
	}

	// 2. Load repo metadata to get the path
	systemRef := "refs/heads/gitgroove/system"
	oldTip, err := gitUtil.ResolveRef(rootAbsPath, systemRef)
	if err != nil {
		return fmt.Errorf("failed to resolve %s: %w", systemRef, err)
	}

	repos, err := loadExistingRepos(rootAbsPath, oldTip)
	if err != nil {
		return fmt.Errorf("failed to load repo metadata: %w", err)
	}

	targetRepo, ok := repos[targetRepoName]
	if !ok {
		return fmt.Errorf("current branch belongs to unknown repo '%s'", targetRepoName)
	}

	// 3. Validate files
	filesToStage, err := validateStagingFiles(rootAbsPath, targetRepo, files)
	if err != nil {
		return err
	}

	// 4. Batch Stage
	if len(filesToStage) > 0 {
		// We can pass multiple files to git add
		// gitUtil.StagePath currently takes one file. We need to use runGit directly or update StagePath.
		// Let's use runGit directly here for efficiency.
		args := append([]string{"add", "--"}, filesToStage...)
		if _, err := gitUtil.RunGit(rootAbsPath, args...); err != nil {
			return fmt.Errorf("failed to stage files: %w", err)
		}
	}

	return nil
}

func validateStagingFiles(rootAbsPath string, targetRepo model.Repo, files []string) ([]string, error) {
	targetRepoAbsPath := filepath.Join(rootAbsPath, targetRepo.Path)
	var filesToStage []string

	for _, file := range files {
		// Normalize and resolve absolute path
		cleanFile := fileUtil.NormalizePath(file)
		absFile := cleanFile
		if !filepath.IsAbs(cleanFile) {
			absFile = filepath.Join(rootAbsPath, cleanFile)
		}

		// Check existence
		if !fileUtil.Exists(absFile) {
			return nil, fmt.Errorf("pathspec '%s' did not match any files", file)
		}

		// Verify file is strictly inside the target repo
		rel, err := filepath.Rel(targetRepoAbsPath, absFile)
		if err != nil || strings.HasPrefix(rel, "..") || strings.HasPrefix(rel, "/") {
			return nil, fmt.Errorf("path '%s' is outside the current repository scope (%s)", file, targetRepo.Name)
		}

		// Nested Repo Check
		if err := checkNestedRepo(targetRepoAbsPath, absFile); err != nil {
			return nil, err
		}

		// Collect relative path for batch staging
		relToRoot, _ := filepath.Rel(rootAbsPath, absFile)

		// Forbid staging .gg/ files
		if strings.HasPrefix(relToRoot, ".gg/") || relToRoot == ".gg" {
			return nil, fmt.Errorf("cannot stage GitGroove metadata: %s", relToRoot)
		}

		filesToStage = append(filesToStage, relToRoot)
	}
	return filesToStage, nil
}

func checkNestedRepo(rootAbsPath, fileAbsPath string) error {
	// Start checking from the file's directory
	dir := filepath.Dir(fileAbsPath)

	// Normalize paths for comparison
	root := filepath.Clean(rootAbsPath)
	current := filepath.Clean(dir)

	// Traverse up until we reach the root
	for {
		if current == root {
			break
		}

		// Check for .gitgroverepo marker
		markerPath := filepath.Join(current, ".gitgroverepo")
		if fileUtil.Exists(markerPath) {
			rel, _ := filepath.Rel(root, current)
			return fmt.Errorf("path '%s' belongs to nested repo '%s'", filepath.Base(fileAbsPath), rel)
		}

		// Move up
		parent := filepath.Dir(current)
		if parent == current {
			// Should not happen if we are inside root, but safety break
			break
		}
		current = parent
	}

	return nil
}


================================================================================================
FILE: core/api.go
================================================================================================

package core

import (
	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove"
	"github.com/kuchuk-borom-debbarma/GitGrove/core/internal/grove/doctor"
)

// Init initializes GitGroove on the current Git repository.
// It delegates to the internal grove package.
func Init(absolutePath string) error {
	return grove.Init(absolutePath)
}

// Register records one or more repos (name → path) in the GitGroove metadata.
func Register(rootAbsPath string, repos map[string]string) error {
	return grove.Register(rootAbsPath, repos)
}

// Link defines one or more repo hierarchy relationships (childName → parentName).
func Link(rootAbsPath string, relationships map[string]string) error {
	return grove.Link(rootAbsPath, relationships)
}

// Switch moves the user's working tree to the GitGroove branch associated with the specified repo.
func Switch(rootAbsPath, repoName, branch string) error {
	return grove.Switch(rootAbsPath, repoName, branch)
}

// Doctor returns the current health and status of the GitGroove project.
func Doctor(rootAbsPath string) (string, error) {
	d, err := doctor.GetDoctor(rootAbsPath)
	if err != nil {
		return "", err
	}
	return d.String(), nil
}

// CreateRepoBranch creates a new branch for a specific nested repository.
func CreateRepoBranch(rootAbsPath, repoName, branchName string) error {
	return grove.CreateRepoBranch(rootAbsPath, repoName, branchName)
}

// CheckoutRepo switches the user's working tree to a specific branch of a nested repository.
func CheckoutRepo(rootAbsPath, repoName, branchName string) error {
	return grove.CheckoutRepo(rootAbsPath, repoName, branchName)
}

// Stage adds file contents to the staging area with GitGrove-specific validations.
func Stage(rootAbsPath string, files []string) error {
	return grove.Stage(rootAbsPath, files)
}

// Commit performs a commit with strict GitGrove validations.
func Commit(rootAbsPath, message string) error {
	return grove.Commit(rootAbsPath, message)
}

// Move relocates a registered repository to a new path within the project.
func Move(rootAbsPath, repoName, newRelPath string) error {
	return grove.Move(rootAbsPath, repoName, newRelPath)
}


