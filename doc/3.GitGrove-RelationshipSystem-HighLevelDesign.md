

# **GitGroove — Grove Relationship System (`gitgrove-grove.md`)**

## **Overview**

The **Grove System** defines and maintains the logical hierarchy of directories inside a Git repository.
This hierarchy represents how GitGroove understands and organizes project components, independent of physical folder nesting.

The Grove System is stored and versioned entirely inside the:

```
gitgroove/system
```

branch, ensuring that hierarchy definitions are immutable, traceable, and reproducible.

All repository definitions and relationships are stored inside:

```
.gg/
   repos.jsonl
   hierarchy.jsonl
```

These files form GitGroove’s canonical metadata state.

GitGroove always derives its behavior—including branch creation—from the committed metadata inside `gitgroove/system`.

---

# **1. Purpose of the Grove System**

The Grove System provides:

* A **logical tree** of repos inside a Git repository
* A **flat, append-only metadata structure**
* A reproducible representation of repo identities and relationships
* A source of truth for **branch creation**, **graph traversal**, and **hierarchical operations**

Grove is **not** tied to physical directory nesting.
For example, `/A` can be the parent of `/B` even if `B` is not located inside `A`.

This allows flexible project modeling.

---

# **2. Core Concepts**

## **2.1 Repos (Registration Required)**

A *repo* is a logical unit defined by:

* A **path** (directory inside the Git project)
* A **unique name** (stable ID)

Repos must be **registered before they can be linked**.

Registration records the identity of the repo in metadata.
Linking refers to repos by **name**, never by path.

### **Repo Constraints**

* Path must exist and be inside the Git repo
* Path must not contain a `.git/` directory
* Name must be globally unique
* Path must be unique in `repos.jsonl`
* A repo must be registered before it can participate in any link

---

## **2.2 Relationships (Linking Registered Repos)**

A relationship defines:

```
parentRepoName → childRepoName
```

The linking system operates *only on names*.
Paths never appear in relationship definitions.

A child may have only **one parent** (tree structure).
Cycles are forbidden.

---

# **3. Metadata Files**

GitGroove stores metadata as **JSON Lines (JSONL)** files for efficient streaming.

### **3.1 `.gg/repos.jsonl`**

Each line defines one registered repo:

```json
{"path":"services/billing","name":"billing"}
```

Used for:

* Name → path lookup
* Path → name lookup
* Validating uniqueness
* Ensuring paths exist

Registration **only** appends to this file.

---

### **3.2 `.gg/hierarchy.jsonl`**

Each line defines one parent→child relationship:

```json
{"parent":"services","child":"billing"}
```

Used for:

* Rebuilding the complete hierarchy
* Cycle detection
* Validating structure
* Deriving GitGroove branches

Linking **only** appends to this file.

---

# **4. Repo Registration Workflow**

Repos must be registered before linking.

### Supported commands:

```
gitgroove register <path>:<name> [<path>:<name> ...]
```

### Example:

```
gitgroove register services:services services/billing:billing
```

### GitGroove performs:

### **4.1 Validate environment**

* Inside a Git repository
* Clean working tree
* Not in detached HEAD
* GitGroove initialized

### **4.2 Validate each repo**

* Path exists
* No `.git/` inside folder
* Name is unique
* Path is unique
* Path is inside the Git repo

### **4.3 Append repo definitions**

Each `<path>:<name>` pair becomes one JSONL entry in `repos.jsonl`.

### **4.4 Commit metadata**

Commit `.gg/` changes to:

```
gitgroove/system
```

---

# **5. Relationship Definition Workflow**

Repos must already be registered.

### Supported commands:

```
gitgroove link <parentName>:<childName> [<parentName>:<childName> ...]
```

### Example:

```
gitgroove link services:billing services:payments root:frontend
```

### GitGroove performs:

### **5.1 Validate environment**

Same validation as registration.

### **5.2 Validate each relationship**

* Both names must be registered
* A child may not already have a parent
* Cycle detection is performed
* Parent and child cannot be the same

### **5.3 Append relationship entries**

Each `<parent>:<child>` pair becomes a line in `hierarchy.jsonl`.

### **5.4 Commit metadata**

Commit all changes to `gitgroove/system`.

---

# **6. Derived Branch Creation**

After each metadata commit, GitGroove:

1. Loads `repos.jsonl` and `hierarchy.jsonl` from **the system branch**
2. Reconstructs the full hierarchy graph
3. Ensures each repo has its own Git branch:

```
gitgroove/<repoName>
```

4. Creates missing branches
5. Never deletes or overwrites existing branches

Branches always reflect the **committed Grove state**, not the working directory.

Branches are cheap (≈40 bytes), allowing hundreds or thousands safely.

---

# **7. Batch Operations**

Both registration and linking support **batch input**:

### Register multiple:

```
gitgroove register A:pathA B:pathB C:pathC
```

### Link multiple:

```
gitgroove link A:B C:D E:F
```

All updates are batched into:

* one metadata update
* one commit
* one branch reconstruction pass

Guaranteeing consistency and performance.

---

# **8. Consistency Rules**

### **8.1 No Cycles**

`A → B → C → A` is invalid.

### **8.2 Single Parent Rule**

Each child appears in only one relationship.

### **8.3 Names Must Be Registered**

Links referencing unknown names are rejected.

### **8.4 Repo Clean State Required**

Dirty repos cannot change Grove metadata.

### **8.5 Paths Must Exist**

Missing directories invalidate registration.

---

# **9. Summary**

The Grove System defines the core structure of GitGroove:

* Repos must be **registered first** (`repos.jsonl`)
* Relationships are defined between repo **names** (`hierarchy.jsonl`)
* All metadata updates create a commit on `gitgroove/system`
* GitGroove branches are derived entirely from the committed Grove state
* JSONL files enable scalable, stream-based processing
* Registration and linking support batch operations
* Strong safety and validation rules ensure consistency

This architecture provides a clean, scalable foundation for GitGroove’s hierarchy-aware functionality.
