

# **GitGrove — High-Level Design (v1)**



# **1. Purpose**

GitGrove manages **multiple logical repositories inside a single Git repository**.
It organizes repos, builds hierarchy, and creates **real Git branches** for each logical repo using a namespace-based scheme.

GitGrove does NOT modify Git's core behavior — it simply structures the workspace.

---

# **2. Initialization (`GitGrove init`)**

### **What It Does**

* Requires a valid Git repository
* If `.git` is missing → runs `git init`
* Creates:

  ```
  .GitGrove/
  ```
* Initializes required metadata files
* Creates a dedicated Git branch:

  ```
  GitGrove
  ```

All GitGrove files and metadata live inside `.GitGrove/` and are tracked on the `GitGrove` branch.

---

### **Edge Cases & Challenges**

* **Dirty working tree:**
  Must not switch or modify branches if user has staged changes, conflicts, or uncommitted edits.

* **Detached HEAD:**
  Cannot run initialization if user is on a detached HEAD.

* **Existing `.GitGrove/`:**
  Initialization must detect and not overwrite existing workspace unless user forces it.

* **Invalid metadata (broken JSON):**
  GitGrove must stop if `.GitGrove` is corrupted.

---

# **3. Registering a Repo**

### **What Registering Does**

When user marks a directory as a repo:

* GitGrove stores:

  * unique name
  * path
  * optional parent
* It will create a dedicated **repo main branch**:

  ```
  GitGrove/repos/<repo-name>/branches/main
  ```

This branch contains **only that repo’s directory** (preserved path), not the full project.

---

### **Edge Cases & Challenges**

* **Duplicate repo names:**
  Must be rejected immediately.

* **Directory doesn't exist:**
  Cannot register it.

* **Directory contains `.git/`:**
  Forbidden in v1 — nested Git repos are not allowed.

* **User later moves folder manually:**
  GitGrove cannot detect this → user must update path explicitly.

* **Registering overlapping directories:**
  If repo paths overlap unintentionally, GitGrove must warn or block.

---

# **4. Repo Hierarchy (Linking Repos)**

### **What It Does**

Hierarchy determines parent–child relations between repos.

Two modes:

### **Automatic**

Based on folder structure:

```
a/
   b/    ← b becomes child of a automatically
```

### **Manual Linking**

Users can explicitly set:

```
GitGrove link --parent X --child Y
```

Stored in `hierarchy.json`.

---

### **Edge Cases & Challenges**

* **Cyclic links:**
  Must be prevented immediately.

* **Conflicting definitions:**
  Manual overrides must take precedence over automatic inference.

* **Ambiguous parent selection:**
  If multiple possible parents exist based on path, GitGrove must require user confirmation.

---

# **5. Per-Repo Branches**

*(Real Git branches, namespaced)*

### **Branch Name Format**

For repo named `billing`:

```
GitGrove/repos/billing_repo/branches/main
```

For child repo:

```
GitGrove/repos/services/children/billing_repo/branches/main
```

### **Working Tree Behavior**

When user checks out a repo branch:

* Only the repo’s directory and its contents appear in the working tree
* Path is preserved — e.g., repo at `services/billing/` still appears at `services/billing/`
* All other project directories are absent

### **Why This Works**

* Provides isolated workspace for each repo
* Avoids complexity of flattening or subtree rewrites
* Keeps structure predictable

---

### **Edge Cases & Challenges**

* **Unsafe characters in branch names:**
  GitGrove must sanitize (e.g., slashes in user branches).

* **Leftover files when switching away:**
  Repo branch checkout must ensure the working tree is clean and contain ONLY that repo’s files.

* **Large directories:**
  Branch creation may be slow for massive repos.

* **Deleting repo branches manually:**
  Could break GitGrove; system must detect missing namespaced branches and report clearly.

---

# **6. Per-Repo Commits**

### **What Commits Mean**

Commits made while checked out to a repo branch:

* Modify ONLY files in that repo
* Never affect other directories
* Are stored in the namespace branch:

  ```
  GitGrove/repos/<repo>/branches/<branch>
  ```
* Represent independent evolution for that repo

### **Intended Use**

Developers work on repo-specific tasks without touching the whole project.

---

### **Edge Cases & Challenges**

* **User deletes repo directory before committing:**
  Must warn and block commit on empty/missing repo path.

* **Commit with files outside repo path:**
  Not possible — working tree contains only repo.

* **Untracked repo files missing from branch:**
  Should warn user before commit.

* **Renames inside repo path:**
  Behave like normal Git — GitGrove imposes no special rules.

---

# **7. Per-Repo Merges (within same repo)**

### **Core Idea**

Each repo manages its own isolated branch history.
Merging two branches of the same repo:

```
git merge GitGrove/repos/myrepo/branches/feature
     into
GitGrove/repos/myrepo/branches/main
```

Behaves like a normal Git merge, but only on repo files.

### **What Happens**

* Only repo subtree participates in merge
* Normal Git conflict rules apply
* No other project directories are involved

---

### **Edge Cases & Challenges**

* **Merge conflicts:**
  Must appear ONLY in files inside repo directory.

* **File deletions/renames:**
  Behave as standard Git operations.

* **Merging child repo branches:**
  Only child directory is affected — parent repo files remain untouched.

* **User attempts to merge unrelated repos:**
  Should be prevented; merging branches between two different repos makes no sense.

---

# **8. Working Tree Switching (Project ↔ Repo branch)**

### **Core Idea**

Switching from project branch to repo branch (and back) must maintain safety.

### **Switching into Repo Branch**

* Working tree becomes ONLY the repo subtree
* Must ensure no leftover files
* Must ensure the user isn't losing uncommitted work

### **Switching back to Project Branch**

* Full project tree is restored
* Repo changes made in repo branch remain isolated in the repo branch
* No automatic syncing or merging occurs

---

### **Edge Cases & Challenges**

* **Dirty working tree:**
  User must stash or commit before switching.

* **Untracked files that would be overwritten:**
  GitGrove must detect and warn/block.

* **Repository conflicts leftover:**
  User must resolve before switching away.

* **Failing to restore original branch:**
  Must track last branch safely and warn if restoration fails.

---

# **9. v1 Restrictions**

* No nested `.git/` repos
* No automatic propagation between repo branches and project branches
* No implicit syncing
* User must handle conflicts manually
* Metadata format may evolve later

GitGrove v1 focuses purely on:

* initialization
* registering repos
* linking repos
* per-repo branches
* per-repo commits
* per-repo merges
* safe working tree transitions

