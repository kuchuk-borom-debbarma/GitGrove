

# **GitGroove — Grove Relationship System (`gitgrove-grove.md`)**

## **Overview**

The **Grove System** defines and maintains the logical hierarchy of directories inside a Git repository.
This hierarchy represents how GitGroove understands and organizes project components, independent of physical folder nesting.

The Grove System is stored and versioned entirely inside the:

```
gitgroove/system
```

branch, ensuring that hierarchy definitions are immutable, traceable, and reproducible.

All relationships and repository definitions exist inside:

```
.gg/
   repos.jsonl
   hierarchy.jsonl
```

Commit-based metadata drives all GitGroove behavior, including creation of derived branches.

---

# **1. Purpose of the Grove System**

The Grove System provides:

* A **logical tree** of components (repos) inside a Git repository
* A **flat, append-only metadata structure**
* A mechanism for GitGroove to **reconstruct structure** at any point in history
* A source of truth for **branch creation**, **dependency mapping**, and **hierarchical operations**

Grove is **not** tied to directory nesting.
A repo at `/A` can be the parent of `/B`, even if B is not physically inside A.

This allows flexible project modeling.

---

# **2. Core Concepts**

## **2.1 Repos**

A *repo* is a logical unit defined by:

* A **path** (folder inside the Git repo)
* A **unique name** (acts as a stable ID)

Repos are *not* Git repositories.
They are plain directories with metadata tracked by GitGroove.

### **Repo Constraints**

* Path must exist and be inside the Git repository
* Path must not contain a `.git/` directory
* Name must be globally unique
* Path must be unique in `repos.jsonl`

---

## **2.2 Relationships**

A relationship defines:

```
parentRepo → childRepo
```

Both parent and child are referenced by **name**, not path, to keep the hierarchy stable even if paths change later.

A child can have only **one parent** (tree structure).

Cycles are forbidden.

---

# **3. Metadata Files**

GitGroove stores metadata as line-based JSONL files for efficient streaming and minimal memory usage.

### **3.1 `.gg/repos.jsonl`**

Each line defines one repo:

```json
{"path":"services/billing","name":"billing"}
```

Used for:

* Path → name lookup
* Name → path lookup
* Validation of uniqueness
* Ensuring folder existence

### **3.2 `.gg/hierarchy.jsonl`**

Each line defines one relationship:

```json
{"parent":"services_root","child":"billing"}
```

Used for:

* Rebuilding the hierarchy tree
* Detecting cycles
* Identifying orphan nodes
* Validating structure
* Creating derived branches

---

# **4. Relationship Definition Workflow**

When the user adds new relationships:

```
gitgroove link --parent A --child B
gitgroove link A B C D (multiple)
gitgroove apply-hierarchy file.txt
```

GitGroove performs the following steps:

### **4.1 Validate environment**

* Must be inside a Git repo
* Must be on a clean working tree
* Must not be in detached HEAD
* Must have been initialized with `gitgroove init`

### **4.2 Validate repos**

For each involved repo:

* Path exists
* Repo name is unique
* Path is unique
* Repo is not already registered with another name
* No nested `.git/` inside path

### **4.3 Update metadata**

* Append new entries to `.gg/repos.jsonl` if needed
* Append new parent→child entries to `.gg/hierarchy.jsonl`
* Never overwrite
* Never mutate existing lines

### **4.4 Commit metadata**

Commit the updated `.gg` directory to:

```
gitgroove/system
```

This commit becomes the **canonical state** of the Grove.

---

# **5. Derived Branch Creation**

GitGroove branches are lightweight Git pointers created from metadata.

After committing metadata changes, GitGroove:

1. Loads `repos.jsonl` and `hierarchy.jsonl` from the system branch
2. Reconstructs the full hierarchy graph
3. Ensures each repo has a corresponding branch:

```
gitgroove/<repo-name>
```

4. Creates new branches only if they do **not** already exist
5. Never deletes or overwrites existing branches

Branches are always derived from the **current committed Grove state**, not from uncommitted changes.

Branches are cheap (≈40 bytes each), so large projects are safe.

---

# **6. Batch Relationship Updates**

GitGroove supports defining multiple relationships in a single operation:

```
gitgroove link A B
gitgroove link C D
gitgroove link E F
```

All changes are:

* batched
* appended to the JSONL files
* committed once
* branch reconstruction happens only once

This ensures atomicity, stable history, and performance.

---

# **7. Consistency Rules**

### **7.1 No Cycles**

Any cycle in the form:

```
A → B → C → A
```

is rejected immediately.

### **7.2 Single Parent Rule**

A child may only appear once on the right-hand side of hierarchy lines.

### **7.3 Path Must Exist**

If file-system path is missing → operation error.

### **7.4 Repo Clean State Required**

Dirty repos cannot be modified.

---

# **8. Design Benefits**

* **No full-file loading** (streaming entries is O(1) memory)
* **Commit-driven behavior** ensures reproducibility
* **IDs decoupled from paths** allow future move/rename commands
* **Hierarchy independent of directory nesting** for maximum flexibility
* **Branches derived from metadata** ensure consistency after any change
* **Atomic batch operations** for complex updates

---

# **9. Summary**

The GitGroove Grove System provides a clean, scalable, and Git-integrated mechanism for defining hierarchical relationships between logical repos inside a project.

It is built on:

* Append-only JSONL files
* Metadata commits to `gitgroove/system`
* Derived Git branches
* Stream-based processing for large projects
* Strict safety and validation rules

This architecture forms the foundation of GitGroove’s multi-component, hierarchy-aware behavior.

