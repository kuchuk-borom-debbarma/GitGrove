
# # GitGroove — Initialization Design Document (`init.md`)

## Overview

`gitgroove init` is the entry point for enabling GitGroove inside an existing Git repository.
The initialization process prepares a dedicated internal workspace, sets up GitGroove’s metadata structures, and creates a system branch used to track all GitGroove-specific state.

The purpose of initialization is to establish a **clean, consistent, and reproducible foundation** for all future GitGroove operations.

GitGroove intentionally imposes strict safety rules:

* It **never modifies user code branches directly**
* It **never initializes on dirty repositories**
* It **requires Git to be already initialized**
* It **stores all internal metadata in a hidden `.gg/` directory**
* It **commits only GitGroove metadata to a dedicated `gitgroove/system` branch**

Initialization will fail early if preconditions are not satisfied.

---

# # High-Level Design

The `init` command performs six major actions:

1. **Validate environment**

   * Check the working directory is a valid Git repository.
   * Ensure the repository is in a fully clean state.
   * Verify GitGroove has not already been initialized.

2. **Prepare internal workspace**

   * Create `.gg/` directory at the root of the repo.
   * Generate essential metadata files (currently `grove.json`).

3. **Create system branch**

   * A dedicated branch `gitgroove/system` is created.
   * This branch holds GitGroove internal state and metadata.
   * It must never contain user code or user commits.

4. **Record initial project state**

   * Stage `.gg/`
   * Commit the metadata snapshot to `gitgroove/system`

5. **Switch repository HEAD**

   * After initialization, the repository remains on
     **`gitgroove/system`**
     making the initialization state visible to the user.

6. **Complete initialization**

   * GitGroove is now fully installed and ready for:

     * Repository scanning
     * Nested repo registration
     * Hierarchical composition
     * Metadata synchronization
     * Future GitGroove commands

---

# # Detailed Design

## 1. Environment Validation

### 1.1 Require Existing Git Repository

GitGroove does **not** auto-initialize Git.
This is a conscious safety choice.

Initialization requires:

* `.git/` directory present
* `git rev-parse --is-inside-work-tree` = `true`

If not valid → initialization stops with:

> “GitGroove cannot initialize: not a valid Git repository”

### 1.2 Require Clean Working Tree

GitGroove refuses to run if **any** of the following exist:

* **Staged changes**
* **Unstaged changes**
* **Untracked files**
* **Detached HEAD**

This prevents accidental metadata corruption and ensures that the system’s first snapshot represents a stable starting point.

Errors look like:

```
repository is not clean: staged changes exist; untracked files exist
```

### 1.3 Prevent Multiple Initializations

GitGroove checks for:

* `.gg/` directory
* `gitgroove/system` branch

If either exists, initialization halts to avoid state divergence.

---

## 2. Internal Workspace Preparation

GitGroove creates a dedicated internal folder:

```
/repo-root/.gg/
```

This directory stores:

* Metadata files
* System configuration
* Repository hierarchy definitions
* Future GitGroove object representations

### Current Files Created (v1)

```
.gg/grove.json
```

Empty at first; populated over time by commands such as:

* `gitgroove register`
* `gitgroove scan`
* `gitgroove link`
* etc.

---

## 3. System Branch

All GitGroove metadata exists inside a segregated branch:

```
gitgroove/system
```

### Purpose

* Avoid polluting user branches
* Keep GitGroove’s internal evolution isolated
* Allow safe versioned metadata tracking
* Provide a clear visual separation

### Behavior

* This branch never contains user code
* Only `.gg/` directory is committed here
* Future GitGroove operations append metadata commits here

### Why use a real Git branch?

* Git operations are predictable
* No need for unusual storage formats
* Metadata benefits from Git's diff, merge, rollback, etc.

---

## 4. Recording Initial Metadata

After preparing `.gg/`, GitGroove records the first metadata commit:

1. `git checkout -b gitgroove/system`
2. Stage `.gg/`
3. Commit with message:

```
Initialize GitGroove system branch
```

### Result

The repository now has:

* Initial user commit(s)
* Plus one system commit:

```
initial commit          <-- user
Initialize GitGroove…   <-- system
```

This establishes a clean baseline for all future GitGroove operations.

---

## 5. Final HEAD Position

GitGroove deliberately leaves HEAD on:

```
gitgroove/system
```

### Why?

* Makes initialization visible and explicit
* Signals to the user that GitGroove is active
* Avoids confusion with additional automatic checkout behavior
* Encourages the user to switch back intentionally

Example guidance:

```
Initialization complete.
You are now on gitgroove/system.
Switch to your working branch when ready.
```

---

# # Error Handling and Edge Cases

| Condition                   | Behavior |
| --------------------------- | -------- |
| No `.git/` directory        | Fail     |
| Detached HEAD               | Fail     |
| Any untracked files         | Fail     |
| Any staged/unstaged changes | Fail     |
| `.gg/` exists               | Fail     |
| `gitgroove/system` exists   | Fail     |
| Git not installed           | Fail     |
| File permissions problems   | Fail     |

GitGroove never attempts automatic cleanup or branch restoration.

---

# # Safety Principles

GitGroove initialization is designed around four core safety rules:

### 1. **Never modify user branches**

Only the system branch (`gitgroove/system`) is touched.

### 2. **Never auto-resolve dirty states**

If the repo is dirty, initialization simply stops.

### 3. **Never auto-initialize Git**

Git must already exist, ensuring intentional user control.

### 4. **Never overwrite existing metadata**

Existing `.gg/` or system branch means initialization has already occurred.

---

# # Summary of Initialization Workflow

```
User runs:
    gitgroove init

GitGroove performs:
    1. Validate Git repo
    2. Validate clean state
    3. Ensure no previous GitGroove installation
    4. Create .gg/
    5. Create grove.json
    6. Create gitgroove/system branch
    7. Commit metadata
    8. Leave HEAD on gitgroove/system

Result:
    GitGroove successfully initialized.
```

